{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AviScript Language Reference","text":"<p>This is a stand-alone reference for the AviScript scripting language.</p>"},{"location":"sidebar/","title":"Sidebar","text":"<ul> <li>Home</li> <li> <p>Control Flow</p> <ul> <li>Do</li> <li>For</li> <li>If</li> <li>Loop</li> <li>Return</li> <li>Switch</li> <li>Throw</li> <li>Try\u2011Catch</li> <li>While</li> </ul> </li> <li> <p>Events</p> <ul> <li>On Intent</li> <li>On Start / On End</li> </ul> </li> <li> <p>Functions</p> <ul> <li>Functions</li> <li>Fn Closure</li> <li>Fn Metadata</li> <li>Fn Method</li> <li>Overload</li> <li>Helpers<ul> <li>Num Fn</li> <li>String Fn</li> </ul> </li> </ul> </li> <li> <p>Operators</p> <ul> <li>Assignment\u2011Op</li> <li>Convert</li> <li>Num\u2011Op</li> <li>Operators</li> </ul> </li> <li> <p>Statements</p> <ul> <li>Eval</li> <li>Statements</li> </ul> </li> <li> <p>Types</p> <ul> <li>Arrays</li> <li>Bit\u2011Fields</li> <li>Blobs</li> <li>Dynamic<ul> <li>Dynamic</li> <li>Dynamic\u2011Tag</li> </ul> </li> <li>Numbers</li> <li>Object\u2011Maps</li> </ul> </li> <li>Fn Ptr</li> <li>OOP<ul> <li>Getters\u2011Setters</li> <li>Methods</li> </ul> </li> <li>Strings\u2011Chars</li> <li>Timestamps</li> <li> <p>Values and Types</p> </li> <li> <p>Variables</p> <ul> <li>Assignment</li> <li>Indexing</li> <li>Ranges</li> <li>Variables</li> <li>Constants</li> </ul> </li> <li> <p>Meta / Utilities</p> <ul> <li>Comments</li> <li>Keywords</li> <li>Print\u2011Debug</li> <li>Type\u2011Of</li> </ul> </li> <li> <p>Modules</p> <ul> <li>Built\u2011in Modules<ul> <li>Ask</li> <li>Assets</li> <li>Config</li> <li>Context</li> <li>HTTP</li> <li>Speak</li> <li>Translation</li> </ul> </li> <li>Export</li> <li>Import </li> </ul> </li> </ul>"},{"location":"control-flow/","title":"Control Flow","text":"<p>Branches and loops that control the execution of code.</p>"},{"location":"control-flow/#contents","title":"Contents","text":""},{"location":"control-flow/do/","title":"Do Loop","text":"<p><code>do</code> loops have two opposite variants: <code>do</code> ... <code>while</code> and <code>do</code> ... <code>until</code>.</p> <p><code>continue</code> can be used to skip to the next iteration, by-passing all following statements; <code>break</code> can be used to break out of the loop unconditionally.</p> <pre><code>let x = 10;\n\ndo {\n    x -= 1;\n    if x &lt; 6 { continue; }  // skip to the next iteration\n    print(x);\n    if x == 5 { break; }    // break out of do loop\n} while x &gt; 0;\n\n\ndo {\n    x -= 1;\n    if x &lt; 6 { continue; }  // skip to the next iteration\n    print(x);\n    if x == 5 { break; }    // break out of do loop\n} until x == 0;\n</code></pre>"},{"location":"control-flow/do/#do-expression","title":"Do Expression","text":"<p><code>do</code> statements can also be used as expressions.</p> <p>The <code>break</code> statement takes an optional expression that provides the return value.</p> <p>The default return value of a <code>do</code> expression is <code>()</code>.</p> <pre><code>let x = 0;\n\n// 'do' can be used just like an expression\nlet result = do {\n    if is_magic_number(x) {\n        // if the 'do' loop breaks here, return a specific value\n        break get_magic_result(x);\n    }\n\n    x += 1;\n\n    // ... if the 'do' loop exits here, the return value is ()\n} until x &gt;= 100;\n\nif result == () {\n    print(\"Magic number not found!\");\n} else {\n    print(`Magic result = ${result}!`);\n}\n</code></pre>"},{"location":"control-flow/for/","title":"For Loop","text":"<p>Iterating through a numeric range or an array, or any iterable type, is provided by the <code>for</code> ... <code>in</code> loop.</p> <p>There are two alternative syntaxes, one including a counter variable:</p> <p><code>for</code> variable <code>in</code> expression <code>{</code> ... <code>}</code></p> <p><code>for (</code> variable <code>,</code> counter <code>)</code> <code>in</code> expression <code>{</code> ... <code>}</code></p>"},{"location":"control-flow/for/#break-or-continue","title":"Break or Continue","text":"<p><code>continue</code> can be used to skip to the next iteration, by-passing all following statements; <code>break</code> can be used to break out of the loop unconditionally.</p>"},{"location":"control-flow/for/#for-expression","title":"For Expression","text":"<p><code>for</code> statements can also be used as expressions.</p> <p>The <code>break</code> statement takes an optional expression that provides the return value.</p> <p>The default return value of a <code>for</code> expression is <code>()</code>.</p> <pre><code>let a = [42, 123, 999, 0, true, \"hello\", \"world!\", 987.6543];\n\n// 'for' can be used just like an expression\nlet index = for (item, count) in a {\n    // if the 'for' loop breaks here, return a specific value\n    switch item.type_of() {\n        \"i64\" if item.is_even =&gt; break count,\n        \"f64\" if item.to_int().is_even =&gt; break count,\n    }\n\n    // ... if the 'for' loop exits here, the return value is ()\n};\n\nif index == () {\n    print(\"Magic number not found!\");\n} else {\n    print(`Magic number found at index ${index}!`);\n}\n</code></pre>"},{"location":"control-flow/for/#counter-variable","title":"Counter Variable","text":"<p>The counter variable, if specified, starts from zero, incrementing upwards.</p> <p>```js , no_run let a = [42, 123, 999, 0, true, \"hello\", \"world!\", 987.6543];</p> <p>// Loop through the array for (item, count) in a {     if x.type_of() == \"string\" {         continue;                   // skip to the next iteration     }</p> <pre><code>// 'item' contains a copy of each element during each iteration\n// 'count' increments (starting from zero) for each iteration\nprint(`Item #${count + 1} = ${item}`);\n\nif x == 42 { break; }           // break out of for loop\n</code></pre> <p>} ```   Iterate Through Arrays</p> <p>Iterating through an array yields cloned copies of each element.  <code>rust let a = [1, 3, 5, 7, 9, 42];  // Loop through the array for x in a {     if x &gt; 10 { continue; }         // skip to the next iteration      print(x);      if x == 42 { break; }           // break out of for loop }</code></p>"},{"location":"control-flow/for/#iterate-through-strings","title":"Iterate Through Strings","text":"<p>Iterating through a string yields individual characters.</p> <p>The <code>chars</code> method also allow iterating through characters in a string, optionally accepting the character position to start from (counting from the end if negative), as well as the number of characters to iterate (defaults to all).</p> <p><code>char</code> also accepts a range which can be created via the <code>..</code> (exclusive) and <code>..=</code> (inclusive) operators.</p> <pre><code>let s = \"hello, world!\";\n\n// Iterate through all the characters.\nfor ch in s {\n    print(ch);\n}\n\n// Iterate starting from the 3rd character and stopping at the 7th.\nfor ch in s.chars(2, 5) {\n    if ch &gt; 'z' { continue; }       // skip to the next iteration\n\n    print(ch);\n\n    if x == '@' { break; }          // break out of for loop\n}\n\n// Iterate starting from the 3rd character and stopping at the end.\nfor ch in s.chars(2..s.len) {\n    if ch &gt; 'z' { continue; }       // skip to the next iteration\n\n    print(ch);\n\n    if x == '@' { break; }          // break out of for loop\n}\n</code></pre>"},{"location":"control-flow/for/#iterate-through-numeric-ranges","title":"Iterate Through Numeric Ranges","text":"<p>ranges are created via the <code>..</code> (exclusive) and <code>..=</code> (inclusive) operators.</p> <p>The <code>range</code> function similarly creates exclusive ranges, plus allowing optional step values.</p> <pre><code>// Iterate starting from 0 and stopping at 49\n// The step is assumed to be 1 when omitted for integers\nfor x in 0..50 {\n    if x &gt; 10 { continue; }         // skip to the next iteration\n\n    print(x);\n\n    if x == 42 { break; }           // break out of for loop\n}\n\n// The 'range' function is just the same\nfor x in range(0, 50) {\n    if x &gt; 10 { continue; }         // skip to the next iteration\n\n    print(x);\n\n    if x == 42 { break; }           // break out of for loop\n}\n\n// The 'range' function also takes a step\nfor x in range(0, 50, 3) {          // step by 3\n    if x &gt; 10 { continue; }         // skip to the next iteration\n\n    print(x);\n\n    if x == 42 { break; }           // break out of for loop\n}\n\n// The 'range' function can also step backwards\nfor x in range(50..0, -3) {         // step down by -3\n    if x &lt; 10 { continue; }         // skip to the next iteration\n\n    print(x);\n\n    if x == 42 { break; }           // break out of for loop\n}\n\n// It works also for floating-point numbers\nfor x in range(5.0, 0.0, -2.0) {    // step down by -2.0\n    if x &lt; 10 { continue; }         // skip to the next iteration\n\n    print(x);\n\n    if x == 4.2 { break; }          // break out of for loop\n}\n</code></pre>"},{"location":"control-flow/for/#iterate-through-bit-fields","title":"Iterate Through Bit-Fields","text":"<p>The <code>bits</code> function allows iterating through an integer as a bit-field.</p> <p><code>bits</code> optionally accepts the bit number to start from (counting from the most-significant-bit if negative), as well as the number of bits to iterate (defaults all).</p> <p><code>bits</code> also accepts a range which can be created via the <code>..</code> (exclusive) and <code>..=</code> (inclusive) operators.</p> <p>```js , no_run let x = 0b_1001110010_1101100010_1100010100; let num_on = 0;</p> <p>// Iterate through all the bits for bit in x.bits() {     if bit { num_on += 1; } }</p> <p>print(<code>There are ${num_on} bits turned on!</code>);</p> <p>const START = 3;</p> <p>// Iterate through all the bits from 3 through 12 for (bit, index) in x.bits(START, 10) {     print(<code>Bit #${index} is ${if bit { \"ON\" } else { \"OFF\" }}!</code>);</p> <pre><code>if index &gt;= 7 { break; }        // break out of for loop\n</code></pre> <p>}</p> <p>// Iterate through all the bits from 3 through 12 for (bit, index) in x.bits(3..=12) {     print(<code>Bit #${index} is ${if bit { \"ON\" } else { \"OFF\" }}!</code>);</p> <pre><code>if index &gt;= 7 { break; }        // break out of for loop\n</code></pre> <p>} ```  Iterate Through Object Maps</p> <p>Two methods, <code>keys</code> and <code>values</code>, return arrays containing cloned copies of all property names and values of an object map, respectively.  These arrays can be iterated.  <code>rust let map = #{a:1, b:3, c:5, d:7, e:9};  // Property names are returned in unsorted, random order for x in map.keys() {     if x &gt; 10 { continue; }         // skip to the next iteration      print(x);      if x == 42 { break; }           // break out of for loop }  // Property values are returned in unsorted, random order for val in map.values() {     print(val); }</code></p>"},{"location":"control-flow/if/","title":"If Statement","text":"<p><code>if</code> statements follow C syntax.</p> <pre><code>if foo(x) {\n    print(\"It's true!\");\n} else if bar == baz {\n    print(\"It's true again!\");\n} else if baz.is_foo() {\n    print(\"Yet again true.\");\n} else if foo(bar - baz) {\n    print(\"True again... this is getting boring.\");\n} else {\n    print(\"It's finally false!\");\n}\n</code></pre> <p>~~~admonish warning.small \"Braces are mandatory\"</p> <p>Unlike C, the condition expression does not need to be enclosed in parentheses <code>(</code>...<code>)</code>, but all branches of the <code>if</code> statement must be enclosed within braces <code>{</code>...<code>}</code>, even when there is only one statement inside the branch.</p> <p>There is no ambiguity regarding which <code>if</code> clause a branch belongs to.</p> <p><pre><code>// AviScript is not C!\nif (decision) print(42);\n//            ^ syntax error, expecting '{'\n</code></pre> <pre><code>If Expression\n=============\n\n`if` statements can also be used as _expressions_, replacing the `? :` conditional operators in\nother C-like languages.\n\n```rust\n// The following is equivalent to C: int x = 1 + (decision ? 42 : 123) / 2;\nlet x = 1 + if decision { 42 } else { 123 } / 2;\nx == 22;\n\nlet x = if decision { 42 }; // no else branch defaults to '()'\nx == ();\n```\n\n~~~admonish danger.small \"Statement before expression\"\n\nBeware that, like Rust, `if` is parsed primarily as a statement where it makes sense.\nThis is to avoid surprises.\n\n```rust\nfn index_of(x) {\n    // 'if' is parsed primarily as a statement\n    if this.contains(x) {\n        return this.find_index(x)\n    }\n\n    -1\n}\n```\n\nThe above will not be parsed as a single expression:\n\n```rust\nfn index_of(x) {\n    if this.contains(x) { return this.find_index(x) } - 1\n    //                          error due to '() - 1' ^\n}\n\n```\n\nTo force parsing as an expression, parentheses are required:\n\n```rust\nfn calc_index(b, offset) {\n    (if b { 1 } else { 0 }) + offset\n//  ^---------------------^ parentheses\n}\n```\n</code></pre></p>"},{"location":"control-flow/loop/","title":"Infinite Loop","text":"<p>Infinite loops follow Rust syntax.</p> <p><code>continue</code> can be used to skip to the next iteration, by-passing all following statements; <code>break</code> can be used to break out of the loop unconditionally.</p> <pre><code>let x = 10;\n\nloop {\n    x -= 1;\n\n    if x &gt; 5 { continue; }  // skip to the next iteration\n\n    print(x);\n\n    if x == 0 { break; }    // break out of loop\n}\n</code></pre> <p>~~~admonish danger.small \"Remember the <code>break</code> statement\"</p> <p>A <code>loop</code> statement without a <code>break</code> statement inside its loop block is infinite. There is no way for the loop to stop iterating. ~~~</p>"},{"location":"control-flow/loop/#loop-expression","title":"Loop Expression","text":"<p><code>loop</code> statements can also be used as expressions.</p> <p>The <code>break</code> statement takes an optional expression that provides the return value.</p> <p>The default return value of a <code>loop</code> expression is <code>()</code>.</p> <p>```js let x = 0;</p> <p>// 'loop' can be used just like an expression let result = loop {     if is_magic_number(x) {         // if the loop breaks here, return a specific value         break get_magic_result(x);     }</p> <pre><code>x += 1;\n\n// ... if the loop exits here, the return value is ()\n</code></pre> <p>};</p> <p>if result == () {     print(\"Magic number not found!\"); } else {     print(<code>Magic result = ${result}!</code>); } ```</p>"},{"location":"control-flow/return/","title":"Return Value","text":""},{"location":"control-flow/return/#return","title":"<code>return</code>","text":"<p>The <code>return</code> statement is used to immediately stop evaluation and exist the current context (typically a function call) yielding a return value.</p> <pre><code>return;             // equivalent to return ();\n\nreturn 123 + 456;   // returns 579\n</code></pre> <p>A <code>return</code> statement at global level exits the script with the return value as the result.</p> <p>A <code>return</code> statement inside a function call exits with a return value to the caller.</p>"},{"location":"control-flow/return/#exit","title":"<code>exit</code>","text":"<p>Similar to the <code>return</code> statement, the <code>exit</code> function is used to immediately stop evaluation, but it does so regardless of where it is called from, even deep inside nested function calls.</p> <p>The result value of <code>exit</code>, when omitted, defaults to <code>()</code>.</p> <pre><code>fn foo() {\n    exit(42);       // exit with result value 42\n}\nfn bar() {\n    foo();\n}\nfn baz() {\n    bar();\n}\n\nlet x = baz();      // exits with result value 42\n\nprint(x);           // &lt;- this is never run\n</code></pre>"},{"location":"control-flow/switch/","title":"Switch Statement","text":"<p>The <code>switch</code> statement allows matching on literal values.</p> <pre><code>switch calc_secret_value(x) {\n    1 =&gt; print(\"It's one!\"),\n    2 =&gt; {\n        // A statements block instead of a one-line statement\n        print(\"It's two!\");\n        print(\"Again!\");\n    }\n    3 =&gt; print(\"Go!\"),\n    // A list of alternatives\n    4 | 5 | 6 =&gt; print(\"Some small number!\"),\n    // _ is the default when no case matches. It must be the last case.\n    _ =&gt; print(`Oops! Something's wrong: ${x}`)\n}\n</code></pre>"},{"location":"control-flow/switch/#default-case","title":"Default Case","text":"<p>A default case (i.e. when no other cases match) can be specified with <code>_</code>.</p> <p>```admonish warning.small \"Must be last\"</p> <p>The default case must be the last case in the <code>switch</code> statement. <pre><code>```js\nswitch wrong_default {\n    1 =&gt; 2,\n    _ =&gt; 9,     // &lt;- syntax error: default case not the last\n    2 =&gt; 3,\n    3 =&gt; 4,     // &lt;- ending with extra comma is OK\n}\n\nswitch wrong_default {\n    1 =&gt; 2,\n    2 =&gt; 3,\n    3 =&gt; 4,\n    _ =&gt; 8,     // &lt;- syntax error: default case not the last\n    _ =&gt; 9\n}\n</code></pre></p>"},{"location":"control-flow/switch/#array-and-object-map-literals-also-work","title":"Array and Object Map Literals Also Work","text":"<p>The <code>switch</code> expression can match against any literal, including array and object map literals.</p> <pre><code>// Match on arrays\nswitch [foo, bar, baz] {\n    [\"hello\", 42, true] =&gt; ...,\n    [\"hello\", 123, false] =&gt; ...,\n    [\"world\", 1, true] =&gt; ...,\n    _ =&gt; ...\n}\n\n// Match on object maps\nswitch map {\n    #{ a: 1, b: 2, c: true } =&gt; ...,\n    #{ a: 42, d: \"hello\" } =&gt; ...,\n    _ =&gt; ...\n}\n</code></pre>"},{"location":"control-flow/switch/#case-conditions","title":"Case Conditions","text":"<p>Similar to Rust, each case (except the default case at the end) can provide an optional condition that must evaluate to <code>true</code> in order for the case to match.</p> <p>All cases are checked in order, so an earlier case that matches will override all later cases.</p> <pre><code>let result = switch calc_secret_value(x) {\n    1 if some_external_condition(x, y, z) =&gt; 100,\n\n    1 | 2 | 3 if x &lt; foo =&gt; 200,    // &lt;- all alternatives share the same condition\n\n    2 if bar() =&gt; 999,\n\n    2 =&gt; \"two\",                     // &lt;- fallback value for 2\n\n    2 =&gt; \"dead code\",               // &lt;- this case is a duplicate and will never match\n                                    //    because the previous case matches first\n\n    5 if CONDITION =&gt; 123,          // &lt;- value for 5 matching condition\n\n    5 =&gt; \"five\",                    // &lt;- fallback value for 5\n\n    _ if CONDITION =&gt; 8888          // &lt;- syntax error: default case cannot have condition\n};\n</code></pre> <p>~~~admonish tip \"Tip: Use with <code>type_of()</code>\"</p> <p>Case conditions, together with <code>type_of()</code>, makes it extremely easy to work with values which may be of several different types (like properties in a JSON object).</p> <p><pre><code>switch value.type_of() {\n    // if 'value' is a string...\n    \"string\" if value.len() &lt; 5 =&gt; ...,\n    \"string\" =&gt; ...,\n\n    // if 'value' is an array...\n    \"array\" =&gt; ...,\n\n    // if 'value' is an object map...\n    \"map\" if value.prop == 42 =&gt; ...,\n    \"map\" =&gt; ...,\n\n    // if 'value' is a number...\n    \"i64\" if value &gt; 0 =&gt; ...,\n    \"i64\" =&gt; ...,\n\n    // anything else: probably an error...\n    _ =&gt; ...\n}\n</code></pre> ~~~</p>"},{"location":"control-flow/switch/#range-cases","title":"Range Cases","text":"<p>Because of their popularity, literal integer ranges can also be used as <code>switch</code> cases.</p> <p>Numeric ranges are only searched when the <code>switch</code> value is itself a number (including floating-point and decimal). They never match any other data types.</p> <p>```admonish warning.small \"Must come after numeric cases\"</p> <p>Range cases must come after all numeric cases. ```</p> <p>```js let x = 42;</p> <p>switch x {     'x' =&gt; ...,             // no match: wrong data type</p> <pre><code>1 =&gt; ...,               // &lt;- specific numeric cases are checked first\n2 =&gt; ...,               // &lt;- but these do not match\n\n0..50 if x &gt; 45 =&gt; ..., // no match: condition is 'false'\n\n-10..20 =&gt; ...,         // no match: not in range\n\n0..50 =&gt; ...,           // &lt;- MATCH!!! duplicated range cases are OK\n\n30..100 =&gt; ...,         // no match: even though it is within range,\n                        // the previous case matches first\n\n42 =&gt; ...,              // &lt;- syntax error: numeric cases cannot follow range cases\n</code></pre> <p>} ```</p> <p>```admonish tip.small \"Tip: Ranges can overlap\"</p> <p>When more then one range contain the <code>switch</code> value, the first one with a fulfilled condition (if any) is evaluated.</p> <p>Numeric range cases are tried in the order that they appear in the original script. ```</p>"},{"location":"control-flow/switch/#switch-expression","title":"Switch Expression","text":"<p>Like <code>if</code>, <code>switch</code> also works as an expression.</p> <p>```admonish tip.small \"Tip\"</p> <p>This means that a <code>switch</code> expression can appear anywhere a regular expression can, e.g. as function call arguments. ```</p> <p>```js let x = switch foo { 1 =&gt; true, _ =&gt; false };</p> <p>func(switch foo {     \"hello\" =&gt; 42,     \"world\" =&gt; 123,     _ =&gt; 0 });</p> <p>// The above is somewhat equivalent to:</p> <p>let x = if foo == 1 { true } else { false };</p> <p>if foo == \"hello\" {     func(42); } else if foo == \"world\" {     func(123); } else {     func(0); } ```</p>"},{"location":"control-flow/switch/#difference-from-if-else-if-chain","title":"Difference From <code>if</code>-<code>else if</code> Chain","text":"<p>Although a <code>switch</code> expression looks almost the same as an <code>if</code>-<code>else if</code> chain, there are subtle differences between the two.</p>"},{"location":"control-flow/switch/#look-up-table-vs-x-y","title":"Look-up Table vs <code>x == y</code>","text":"<p>A <code>switch</code> expression matches through hashing via a look-up table. Therefore, matching is very fast.  Walking down an <code>if</code>-<code>else if</code> chain is much slower.</p> <p>On the other hand, operators can be overloaded in AviScript, meaning that it is possible to override the <code>==</code> operator for integers such that <code>x == y</code> returns a different result from the built-in default.</p> <p><code>switch</code> expressions do not use the <code>==</code> operator for comparison; instead, they hash the data values and jump directly to the correct statements via a pre-compiled look-up table.  This makes matching extremely efficient, but it also means that overloading the <code>==</code> operator will have no effect.</p> <p>Therefore, in environments where it is desirable to overload the <code>==</code> operator for standard types \u2013 though it is difficult to think of valid scenarios where you'd want <code>1 == 1</code> to return something other than <code>true</code> \u2013 avoid using the <code>switch</code> expression.</p>"},{"location":"control-flow/switch/#efficiency","title":"Efficiency","text":"<p>Because the <code>switch</code> expression works through a look-up table, it is very efficient even for large number of cases; in fact, switching is an O(1) operation regardless of the size of the data and number of cases to match.</p> <p>A long <code>if</code>-<code>else if</code> chain becomes increasingly slower with each additional case because essentially an O(n) linear scan is performed.</p>"},{"location":"control-flow/throw/","title":"Throw Exception on Error","text":"<p>To deliberately return an error, use the <code>throw</code> keyword.</p> <pre><code>if some_bad_condition_has_happened {\n    throw error;    // 'throw' any value as the exception\n}\n\nthrow;              // defaults to '()'\n</code></pre>"},{"location":"control-flow/throw/#catch-a-thrown-exception","title":"Catch a Thrown Exception","text":"<p>It is possible to catch an exception, instead of having it abort the script run, via the <code>try</code> ... <code>catch</code> statement common to many C-like languages.</p> <pre><code>fn code_that_throws() {\n    throw 42;\n}\n\ntry\n{\n    code_that_throws();\n}\ncatch (err)         // 'err' captures the thrown exception value\n{\n    print(err);     // prints 42\n}\n</code></pre>"},{"location":"control-flow/try-catch/","title":"Catch Exceptions","text":"<p>When an exception is thrown via a <code>throw</code> statement, the script halts with the exception value.</p> <p>It is possible, via the <code>try</code> ... <code>catch</code> statement, to catch exceptions, optionally with an error variable.</p> <p><code>try</code> <code>{</code> ... <code>}</code> <code>catch</code> <code>{</code> ... <code>}</code></p> <p><code>try</code> <code>{</code> ... <code>}</code> <code>catch</code> <code>(</code> error variable <code>)</code> <code>{</code> ... <code>}</code></p> <pre><code>// Catch an exception and capturing its value\ntry\n{\n    throw 42;\n}\ncatch (err)         // 'err' captures the thrown exception value\n{\n    print(err);     // prints 42\n}\n\n// Catch an exception without capturing its value\ntry\n{\n    print(42/0);    // deliberate divide-by-zero exception\n}\ncatch               // no error variable - exception value is discarded\n{\n    print(\"Ouch!\");\n}\n\n// Exception in the 'catch' block\ntry\n{\n    print(42/0);    // throw divide-by-zero exception\n}\ncatch\n{\n    print(\"You seem to be dividing by zero here...\");\n\n    throw \"die\";    // a 'throw' statement inside a 'catch' block\n                    // throws a new exception\n}\n</code></pre> <p>~~~admonish tip \"Tip: Re-throw exception\"</p> <p>Like the <code>try</code> ... <code>catch</code> syntax in most languages, it is possible to re-throw an exception within the <code>catch</code> block simply by another <code>throw</code> statement without a value.</p> <p><pre><code>try\n{\n    // Call something that will throw an exception...\n    do_something_bad_that_throws();\n}\ncatch\n{\n    print(\"Oooh! You've done something real bad!\");\n\n    throw;          // 'throw' without a value within a 'catch' block\n                    // re-throws the original exception\n}\n</code></pre> ~~~</p> <p>```admonish success \"Catchable exceptions\"</p> <p>Many script-oriented exceptions can be caught via <code>try</code> ... <code>catch</code>.</p> Error type Error value Runtime error thrown by a <code>throw</code> statement value in <code>throw</code> statement Arithmetic error object map Variable not found object map Function not found object map Module not found object map Unbound <code>this</code> object map Data type mismatch object map Assignment to a calculated/constant value object map array/string/bit-field indexing out-of-bounds object map Indexing with an inappropriate data type object map Error in property access object map <code>for</code> statement on a type that is not iterable object map Data race detected object map Other runtime error object map <p>The error value in the <code>catch</code> clause is an object map containing information on the particular error, including its type, line and character position (if any), and source etc. ```</p> <p>```admonish failure \"Non-catchable exceptions\"</p> <p>Some system exceptions cannot be caught.</p> Error type Notes System error \u2013 e.g. script file not found system errors are not recoverable Syntax error during parsing invalid script [Custom syntax] mismatch error incompatible [<code>Engine</code>] instance Script evaluation metrics exceeding [limits][safety] [safety] protection Script evaluation manually terminated [safety] protection ```"},{"location":"control-flow/while/","title":"While Loop","text":"<p><code>while</code> loops follow C syntax.</p> <p><code>continue</code> can be used to skip to the next iteration, by-passing all following statements; <code>break</code> can be used to break out of the loop unconditionally.</p> <pre><code>let x = 10;\n\nwhile x &gt; 0 {\n    x -= 1;\n    if x &lt; 6 { continue; }  // skip to the next iteration\n    print(x);\n    if x == 5 { break; }    // break out of while loop\n}\n</code></pre>"},{"location":"control-flow/while/#while-expression","title":"While Expression","text":"<p><code>while</code> statements can also be used as expressions.</p> <p>The <code>break</code> statement takes an optional expression that provides the return value.</p> <p>The default return value of a <code>while</code> expression is <code>()</code>.</p> <pre><code>let x = 0;\n\n// 'while' can be used just like an expression\nlet result = while x &lt; 100 {\n    if is_magic_number(x) {\n        // if the 'while' loop breaks here, return a specific value\n        break get_magic_result(x);\n    }\n\n    x += 1;\n\n    // ... if the 'while' loop exits here, the return value is ()\n};\n\nif result == () {\n    print(\"Magic number not found!\");\n} else {\n    print(`Magic result = ${result}!`);\n}\n</code></pre>"},{"location":"events/","title":"Events","text":"<p>Event hooks (on_start, on_end, on_intent, \u2026) for reactive scripts.</p>"},{"location":"events/#contents","title":"Contents","text":"<p>On Intent On Start On End</p>"},{"location":"events/on_intent/","title":"on_intent","text":"<p>The <code>on_intent</code> syntax provides a way to define handlers for specific user intents in your AviScript skills.</p>"},{"location":"events/on_intent/#syntax","title":"Syntax","text":"<pre><code>on_intent \"intent_name\" {\n    // Code to execute when this intent is detected\n}\n</code></pre>"},{"location":"events/on_intent/#parameters","title":"Parameters","text":"<ul> <li><code>intent_name</code>: A string matching the name of an intent defined in your skill's intents directory</li> </ul>"},{"location":"events/on_intent/#scope-variables","title":"Scope Variables","text":"<p>When an intent handler is triggered, the following constants are available in the scope:</p> <ul> <li><code>name</code>: The name of the matched intent</li> <li><code>intent</code>: The <code>Intent</code> object containing extracted slots and information</li> </ul>"},{"location":"events/on_intent/#example","title":"Example","text":"<pre><code>on_intent \"get_weather\" {\n    let location = intent.optional(\"location\", \"current\");\n    let date = intent.optional(\"date\", \"today\");\n\n    speak.say(\"weather_report\", #{\n        \"location\": location,\n        \"date\": date\n    });\n\n    // Fetch and display weather data\n    let weather_data = http.get(\"/api/weather\", #{ \n        \"location\": location, \n        \"date\": date \n    });\n\n    // Process weather_data and respond to user\n}\n</code></pre>"},{"location":"events/on_intent/#intent-object-methods","title":"Intent Object Methods","text":"<p>The <code>intent</code> object provides several methods to access slot data:</p> <ul> <li><code>get(slot_name)</code>: Get a slot value or null if not present</li> <li><code>get_raw(slot_name)</code>: Get the raw slot value</li> <li><code>require(slot_name)</code>: Get a slot value or throw an error if not present</li> <li><code>optional(slot_name, default_value)</code>: Get a slot value or return default if not present</li> <li><code>exists(slot_name)</code>: Check if a slot exists</li> <li><code>equal(slot_name, value)</code>: Check if a slot equals a specific value</li> <li><code>in_list(slot_name, list)</code>: Check if a slot value is in a list</li> <li><code>in_dict(slot_name, dict)</code>: Check if a slot is a key in a dictionary</li> <li><code>obj()</code>: Get the full intent object as a map</li> <li><code>count()</code>: Get the number of slots</li> <li><code>all()</code>: Get all slots as a map</li> </ul>"},{"location":"events/on_start_on_end/","title":"on_start/on_end","text":"<p>The <code>on_start</code> and <code>on_end</code> syntax provides lifecycle hooks for your AviScript skills.</p>"},{"location":"events/on_start_on_end/#on_start","title":"on_start","text":"<p>The <code>on_start</code> handler is executed when your skill is initialized, before any intents are processed.</p>"},{"location":"events/on_start_on_end/#syntax","title":"Syntax","text":"<pre><code>on_start {\n    // Code to execute when skill starts\n}\n</code></pre>"},{"location":"events/on_start_on_end/#example","title":"Example","text":"<pre><code>on_start {\n    // Initialize skill state\n    let welcome_shown = context.load(\"welcome_shown\");\n\n    if !welcome_shown {\n        speak.say(\"welcome_message\", #{});\n        context.save(\"welcome_shown\", true);\n    }\n\n    // Load user preferences\n    let user_settings = assets.read_json(\"user_settings.json\");\n    context.save(\"settings\", user_settings);\n}\n</code></pre>"},{"location":"events/on_start_on_end/#on_end","title":"on_end","text":"<p>The <code>on_end</code> handler is executed when your skill is stopping or being unloaded.</p>"},{"location":"events/on_start_on_end/#syntax_1","title":"Syntax","text":"<pre><code>on_end {\n    // Code to execute when skill ends\n}\n</code></pre>"},{"location":"events/on_start_on_end/#example_1","title":"Example","text":"<pre><code>on_end {\n    // Clean up resources\n    assets.audio.stop();\n\n    // Save user state\n    let user_data = context.load(\"user_data\");\n    assets.write_json(\"user_data.json\", user_data);\n\n    // Say goodbye\n    speak.say(\"goodbye_message\", #{});\n}\n</code></pre>"},{"location":"events/on_start_on_end/#usage-notes","title":"Usage Notes","text":"<ul> <li><code>on_start</code> runs exactly once when the skill is loaded</li> <li><code>on_end</code> runs when the skill is explicitly stopped or unloaded</li> <li>Use these handlers to initialize and clean up resources, load and save persistent data, and manage user experience</li> </ul>"},{"location":"functions/","title":"Functions","text":"<p>Reusable blocks of code: definitions, callbacks, pointers, closures, and overloads.</p>"},{"location":"functions/#contents","title":"Contents","text":"<p>Fn Closure Fn Metadata Fn Method Functions Overload</p>"},{"location":"functions/fn-closure/","title":"Closures","text":"<p>Many functions in the standard API expect function pointer as parameters.</p> <p>For example:</p> <pre><code>// Function 'double' defined here - used only once\nfn double(x) { 2 * x }\n\n// Function 'square' defined here - again used only once\nfn square(x) { x * x }\n\nlet x = [1, 2, 3, 4, 5];\n\n// Pass a function pointer to 'double'\nlet y = x.map(double);\n\n// Pass a function pointer to 'square' using Fn(...) notation\nlet z = y.map(Fn(\"square\"));\n</code></pre> <p>Sometimes it gets tedious to define separate functions only to dispatch them via single function pointers \u2013 essentially, those functions are only ever called in one place.</p> <p>This scenario is especially common when simulating object-oriented programming ([OOP]).</p> <pre><code>// Define functions one-by-one\nfn obj_inc(x, y) { this.data += x * y; }\nfn obj_dec(x) { this.data -= x; }\nfn obj_print() { print(this.data); }\n\n// Define object\nlet obj = #{\n    data: 42,\n    increment: obj_inc,     // use function pointers to\n    decrement: obj_dec,     // refer to method functions\n    print: obj_print\n};\n</code></pre>"},{"location":"functions/fn-closure/#syntax","title":"Syntax","text":"<p>Closures have a syntax similar to Rust's closures (they are not the same).</p> <p><code>|</code>param 1<code>,</code> param 2<code>,</code> ... <code>,</code> param n<code>|</code> statement </p> <p><code>|</code>param 1<code>,</code> param 2<code>,</code> ... <code>,</code> param n<code>| {</code> statements... <code>}</code> </p> <p>No parameters:</p> <p><code>||</code> statement </p> <p><code>|| {</code> statements... <code>}</code></p>"},{"location":"functions/fn-closure/#rewrite-using-closures","title":"Rewrite Using Closures","text":"<p>The above can be rewritten using closures.</p> <pre><code>let x = [1, 2, 3, 4, 5];\n\nlet y = x.map(|x| 2 * x);\n\nlet z = y.map(|x| x * x);\n\nlet obj = #{\n    data: 42,\n    increment: |x, y| this.data += x * y,   // one statement\n    decrement: |x| this.data -= x,          // one statement\n    print_obj: || {\n        print(this.data);                   // full function body\n    }\n};\n</code></pre> <p>This de-sugars to:</p> <pre><code>// Automatically generated...\nfn anon_fn_0001(x) { 2 * x }\nfn anon_fn_0002(x) { x * x }\nfn anon_fn_0003(x, y) { this.data += x * y; }\nfn anon_fn_0004(x) { this.data -= x; }\nfn anon_fn_0005() { print(this.data); }\n\nlet x = [1, 2, 3, 4, 5];\n\nlet y = x.map(anon_fn_0001);\n\nlet z = y.map(anon_fn_0002);\n\nlet obj = #{\n    data: 42,\n    increment: anon_fn_0003,\n    decrement: anon_fn_0004,\n    print: anon_fn_0005\n};\n</code></pre>"},{"location":"functions/fn-closure/#capture-external-variables","title":"Capture External Variables","text":"<p>~~~admonish tip.side \"Tip: <code>is_shared</code>\"</p> <p>Use <code>is_shared</code> to check whether a particular dynamic value is shared. <pre><code>Closures differ from standard functions because they can _captures_ [variables](variables/variables.md) that\nare not defined within the current scope, but are instead defined in an external scope &amp;ndash; i.e.\nwhere the it is created.\n\nAll [variables](variables/variables.md) that are accessible during the time the closure is created are\nautomatically captured when they are used, as long as they are not shadowed by local\n[variables](variables/variables.md) defined within the function's.\n\nThe captured [variables](variables/variables.md) are automatically converted into **reference-counted shared values**.\n\nTherefore, similar to closures in many languages, these captured shared values persist through\nreference counting, and may be read or modified even after the [variables](variables/variables.md) that hold\nthem go out of scope and no longer exist.\n\n```rust\nlet x = 1;                          // a normal variable\n\nx.is_shared() == false;\n\nlet f = |y| x + y;                  // variable 'x' is auto-curried (captured) into 'f'\n\nx.is_shared() == true;              // 'x' is now a shared value!\n\nf.call(2) == 3;                     // 1 + 2 == 3\n\nx = 40;                             // changing 'x'...\n\nf.call(2) == 42;                    // the value of 'x' is 40 because 'x' is shared\n\n// The above de-sugars into something like this:\n\nfn anon_0001(x, y) { x + y }        // parameter 'x' is inserted\n\nmake_shared(x);                     // convert variable 'x' into a shared value\n\nlet f = anon_0001.curry(x);         // shared 'x' is curried\n```\n\n\n~~~admonish bug \"Beware: Captured variables are truly shared\"\n\nThe example below is a typical tutorial sample for many languages to illustrate the traps\nthat may accompany capturing external [variables](variables/variables.md) in closures.\n\nIt prints `9`, `9`, `9`, ... `9`, `9`, not `0`, `1`, `2`, ... `8`, `9`, because there is ever only\n_one_ captured [variable](variables/variables.md), and all ten closures capture the _same_\n[variable](variables/variables.md).\n\n```rust\nlet list = [];\n\nfor i in 0..10 {\n    list.push(|| print(i));     // the for loop variable 'i' is captured\n}\n\nlist.len() == 10;               // 10 closures stored in the array\n\nlist[0].type_of() == \"Fn\";      // make sure these are closures\n\nfor f in list {\n    f.call();                   // all references to 'i' point to the same variable!\n}\n```\n</code></pre></p> <p>~~~admonish danger \"Prevent data races\"</p> <p>Data races are possible in AviScript scripts.</p> <p>Avoid performing a method call on a captured shared variable (which essentially takes a mutable reference to the shared object) while using that same variable as a parameter in the method call \u2013 this is a sure-fire way to generate a data race error.</p> <p>If a shared value is used as the <code>this</code> pointer in a method call to a closure function, then the same shared value must not be captured inside that function, or a data race will occur and the script will terminate with an error.</p> <p><pre><code>let x = 20;\n\nx.is_shared() == false;         // 'x' not shared, so no data races\n\nlet f = |a| this += x + a;      // 'x' is captured in this closure\n\nx.is_shared() == true;          // now 'x' is shared\n\nx.call(f, 2);                   // &lt;- error: data race detected on 'x'\n</code></pre> ~~~</p>"},{"location":"functions/fn-metadata/","title":"Functions Metadata","text":"<p>The metadata of a function means all relevant information related to a function's definition including:</p> <ol> <li> <p>Its callable name</p> </li> <li> <p>Its access mode (public or private)</p> </li> <li> <p>Its parameter names (if any)</p> </li> <li> <p>Its purpose, in the form of doc-comments</p> </li> <li> <p>Usage notes, warnings, examples etc., in the form of doc-comments</p> </li> </ol> <p>A function's signature encapsulates the first three pieces of information in a single concise line of definition:</p> <p><code>[private]</code> name <code>(</code>param 1<code>,</code> param 2<code>,</code> ... <code>,</code> param n <code>)</code></p>"},{"location":"functions/fn-metadata/#get-functions-metadata","title":"Get Functions Metadata","text":"<p>The built-in function <code>get_fn_metadata_list</code> returns an array of object maps, each containing the metadata of one script-defined function in scope.</p> <p><code>get_fn_metadata_list</code> has a few versions taking different parameters:</p> Signature Description <code>get_fn_metadata_list()</code> returns an array for all script-defined functions <code>get_fn_metadata_list(name)</code> returns an array containing all script-defined functions matching a specified name <code>get_fn_metadata_list(name, params)</code> returns an array containing all script-defined functions matching a specified name and accepting the specified number of parameters <p>The return value is an array of object maps containing the following fields.</p> Field Type Optional? Description <code>namespace</code> string yes the module namespace if the function is defined within a module <code>access</code> string no <code>\"public\"</code> if the function is public,<code>\"private\"</code> if it is private <code>name</code> string no function name <code>params</code> array of strings no parameter names <code>this_type</code> string yes restrict the type of <code>this</code> if the function is a method <code>is_anonymous</code> <code>bool</code> no is this function an anonymous function? <code>comments</code> array of strings yes doc-comments, if any, one per line"},{"location":"functions/fn-method/","title":"<code>this</code> \u2013 Simulating an Object Method","text":"<p>```admonish warning.side \"Functions are pure\"</p> <p>The only way for a script-defined function to change an external value is via <code>this</code>. <pre><code>Arguments passed to script-defined [functions](functions/functions.md) are always by _value_ because\n[functions](functions/functions.md) are _pure_.\n\nHowever, [functions](functions/functions.md) can also be called in _method-call_ style:\n\n&gt; _object_ `.` _method_ `(` _parameters_ ... `)`\n\nWhen a [function](functions/functions.md) is called this way, the keyword `this` binds to the object in the\nmethod call and can be changed.\n\n```rust\nfn change() {       // note that the method does not need a parameter\n    this = 42;      // 'this' binds to the object in method-call\n}\n\nlet x = 500;\n\nx.change();         // call 'change' in method-call style, 'this' binds to 'x'\n\nx == 42;            // 'x' is changed!\n\nchange();           // &lt;- error: 'this' is unbound\n</code></pre></p>"},{"location":"functions/fn-method/#elvis-operator","title":"Elvis Operator","text":"<p>The Elvis operator can be used to short-circuit the method call when the object itself is <code>()</code>.</p> <p>object <code>?.</code> method <code>(</code> parameters ... <code>)</code></p> <p>In the above, the method is never called if object is <code>()</code>.</p>"},{"location":"functions/fn-method/#restrict-the-type-of-this-in-function-definitions","title":"Restrict the Type of <code>this</code> in Function Definitions","text":"<p>```admonish tip.side.wide \"Tip: Automatically global\"</p> <p>Methods defined this way are automatically exposed to the global namespace. <pre><code>In many cases it may be desirable to implement _methods_ for different custom types using\nscript-defined [functions](functions/functions.md).\n\n### The Problem\n\nDoing so is brittle and requires a lot of type checking code because there can only be one\n[function](functions/functions.md) definition for the same name and arity:\n\n```js\n// Really painful way to define a method called 'do_update' on various data types\nfn do_update(x) {\n    switch type_of(this) {\n        \"i64\" =&gt; this *= x,\n        \"string\" =&gt; this.len += x,\n        \"bool\" if this =&gt; this *= x,\n        \"bool\" =&gt; this *= 42,\n        \"MyType\" =&gt; this.update(x),\n        \"Strange-Type#Name::with_!@#symbols\" =&gt; this.update(x),\n        _ =&gt; throw `I don't know how to handle ${type_of(this)}`!`\n    }\n}\n</code></pre></p>"},{"location":"functions/fn-method/#the-solution","title":"The Solution","text":"<p>With a special syntax, it is possible to restrict a function to be callable only when the object pointed to by <code>this</code> is of a certain type:</p> <p><code>fn</code> type name <code>.</code> method <code>(</code> parameters ... <code>)  {</code>  ...  <code>}</code></p> <p>or in quotes if the type name is not a valid identifier itself:</p> <p><code>fn</code> <code>\"</code>type name string<code>\"</code> <code>.</code> method <code>(</code> parameters ... <code>)  {</code>  ...  <code>}</code></p> <p>~~~admonish warning.small \"Type name must be the same as <code>type_of</code>\"</p> <p>The type name specified in front of the function name must match the output of <code>type_of</code> for the required type. <pre><code>~~~admonish tip.small \"Tip: `int` and `float`\"\n`int` can be used in place of the system integer type (usually `i64` or `i32`).\n\n`float` can be used in place of the system floating-point type (usually `f64` or `f32`).\n\nUsing these make scripts more portable.\n</code></pre></p>"},{"location":"functions/fn-method/#examples","title":"Examples","text":"<pre><code>/// This 'do_update' can only be called on objects of type 'MyType' in method style\nfn MyType.do_update(x, y) {\n    this.update(x * y);\n}\n\n/// This 'do_update' can only be called on objects of type 'Strange-Type#Name::with_!@#symbols'\n/// (which can be specified via 'Engine::register_type_with_name') in method style\nfn \"Strange-Type#Name::with_!@#symbols\".do_update(x, y) {\n    this.update(x * y);\n}\n\n/// Define a blanket version\nfn do_update(x, y) {\n    this = `${this}, ${x}, ${y}`;\n}\n\n/// This 'do_update' can only be called on integers in method style\nfn int.do_update(x, y) {\n    this += x * y\n}\n\nlet obj = create_my_type();     // 'x' is 'MyType'\n\nobj.type_of() == \"MyType\";\n\nobj.do_update(42, 123);         // ok!\n\nlet x = 42;                     // 'x' is an integer\n\nx.type_of() == \"i64\";\n\nx.do_update(42, 123);           // ok!\n\nlet x = true;                   // 'x' is a boolean\n\nx.type_of() == \"bool\";\n\nx.do_update(42, 123);           // &lt;- this works because there is a blanket version\n\n// Use 'is_def_fn' with three parameters to test for typed methods\nis_def_fn(\"MyType\", \"do_update\", 2) == true;\n\nis_def_fn(\"int\", \"do_update\", 2) == true;\n</code></pre>"},{"location":"functions/fn-method/#bind-to-this-for-module-functions","title":"Bind to <code>this</code> for Module Functions","text":""},{"location":"functions/fn-method/#the-problem","title":"The Problem","text":"<p>The method-call syntax is not possible for functions imported from modules.</p> <pre><code>import \"my_module\" as foo;\n\nlet x = 42;\n\nx.foo::change_value(1);     // &lt;- syntax error\n</code></pre>"},{"location":"functions/fn-method/#the-solution_1","title":"The Solution","text":"<p>In order to call a module function as a method, it must be defined with a restriction on the type of object pointed to by <code>this</code>:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 my_module.avi \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n// This is a typed method function requiring 'this' to be an integer.\n// Typed methods are automatically marked global when importing this module.\nfn int.change_value(offset) {\n    // 'this' is guaranteed to be an integer\n    this += offset;\n}\n\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 main.avi \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nimport \"my_module\";\n\nlet x = 42;\n\nx.change_value(1);          // ok!\n\nx == 43;\n</code></pre>"},{"location":"functions/functions/","title":"Functions","text":"<p>AviScript supports defining functions in script via the <code>fn</code> keyword.</p> <p>Valid function names are the same as valid variable names.</p> <pre><code>fn add(x, y) {\n    x + y\n}\n\nfn sub(x, y,) {     // trailing comma in parameters list is OK\n    x - y\n}\n\nadd(2, 3) == 5;\n\nsub(2, 3,) == -1;   // trailing comma in arguments list is OK\n</code></pre> <p>~~~admonish tip.small \"Tip: <code>is_def_fn</code>\"</p> <p>Use <code>is_def_fn</code> to detect if a AviScript function is defined (and therefore callable) based on its name and the number of parameters (arity).</p> <p><pre><code>fn foo(x) { x + 1 }\n\nis_def_fn(\"foo\", 1) == true;\n\nis_def_fn(\"foo\", 0) == false;\n\nis_def_fn(\"foo\", 2) == false;\n\nis_def_fn(\"bar\", 1) == false;\n</code></pre> ~~~</p>"},{"location":"functions/functions/#implicit-return","title":"Implicit Return","text":"<p>The last statement of a block is always the block's return value regardless of whether it is terminated with a semicolon <code>;</code>.</p> <p>```rust fn add(x, y) {      // implicit return:     x + y;          // value of the last statement (no need for ending semicolon)                     // is used as the return value }</p> <p>fn add2(x) {     return x + 2;   // explicit return }</p> <p>add(2, 3) == 5;</p> <p>add2(42) == 44; ```</p>"},{"location":"functions/functions/#global-definitions-only","title":"Global Definitions Only","text":"<p>Functions can only be defined at the global level, never inside a block or another function.</p> <p>```rust // Global level is OK fn add(x, y) {     x + y }</p> <p>// The following will not compile fn do_addition(x) {     fn add_y(n) {   // &lt;- syntax error:  cannot define inside another function         n + y     }</p> <pre><code>add_y(x)\n</code></pre> <p>} ```</p>"},{"location":"functions/functions/#no-access-to-external-scope","title":"No Access to External Scope","text":"<p>Functions are not closures. They do not capture the calling environment and can only access their own parameters.</p> <p>They cannot access variables external to the function itself.</p> <p>```rust let x = 42;</p> <p>fn foo() {     x               // &lt;- error: variable 'x' not found } ```</p>"},{"location":"functions/functions/#but-can-call-other-functions-and-access-modules","title":"But Can Call Other Functions and Access Modules","text":"<p>All functions can call each other.</p> <p>```rust fn foo(x) {         // function defined in the global namespace     x + 1 }</p> <p>fn bar(x) {     foo(x)          // ok! function 'foo' can be called } ```</p> <p>In addition, modules imported at global level can be accessed.</p> <p>```js import \"hello\" as hey; import \"world\" as woo;</p> <p>{     import \"x\" as xyz;  // &lt;- this module is not at global level }                       // &lt;- it goes away here</p> <p>fn foo(x) {     hey::process(x);    // ok! imported module 'hey' can be accessed</p> <pre><code>print(woo::value);  // ok! imported module 'woo' can be accessed\n\nxyz::do_work();     // &lt;- error: module 'xyz' not found\n</code></pre> <p>} ```</p>"},{"location":"functions/functions/#automatic-global-module","title":"Automatic Global Module","text":"<p>When a constant is declared at global scope, it is added to a special module called <code>global</code>.</p> <p>Functions can access those constants via the special <code>global</code> module.</p> <p>```rust const CONSTANT = 42;        // this constant is automatically added to 'global'</p> <p>let hello = 1;              // variables are not added to 'global'</p> <p>{     const INNER = 0;        // this constant is not at global level }                           // &lt;- it goes away here</p> <p>fn foo(x) {     x * global::hello       // &lt;- error: variable 'hello' not found in 'global'</p> <pre><code>x * global::CONSTANT    // ok! 'CONSTANT' exists in 'global'\n\nx * global::INNER       // &lt;- error: constant 'INNER' not found in 'global'\n</code></pre> <p>} ```</p>"},{"location":"functions/functions/#use-before-definition-allowed","title":"Use Before Definition Allowed","text":"<p>Unlike C/C++, functions in AviScript can be defined anywhere at global level.</p> <p>A function does not need to be defined prior to being used in a script; a statement in the script can freely call a function defined afterwards.</p> <p>This is similar to Rust and many other modern languages, such as JavaScript's <code>function</code> keyword.</p> <p>```rust let x = foo(41);    // &lt;- I can do this!</p> <p>fn foo(x) {         // &lt;- define 'foo' after use     x + 1 } ```</p>"},{"location":"functions/functions/#arguments-are-passed-by-value","title":"Arguments are Passed by Value","text":"<p>Functions with the same name and same number of parameters are equivalent.</p> <p>All arguments are passed by value, so all AviScript script-defined functions are pure (i.e. they never modify their arguments).</p> <p>Any update to an argument will not be reflected back to the caller.</p> <p>```rust fn change(s) {      // 's' is passed by value     s = 42;         // only a COPY of 's' is changed }</p> <p>let x = 500;</p> <p>change(x);</p> <p>x == 500;           // 'x' is NOT changed! ```</p> <p>```admonish warning.small \"AviScript functions are pure\"</p> <p>The only possibility for a AviScript script-defined function to modify an external variable is via the <code>this</code> pointer. ```</p>"},{"location":"functions/overload/","title":"Function Overloading","text":"<p>Functions defined in script can be overloaded by arity (i.e. they are resolved purely upon the function's name and number of parameters, but not parameter types since all parameters are dynamic).</p> <p>New definitions overwrite previous definitions of the same name and number of parameters.</p> <pre><code>fn foo(x, y, z) {\n    print(`Three!!! ${x}, ${y}, ${z}`);\n}\nfn foo(x) {\n    print(`One! ${x}`);\n}\nfn foo(x, y) {\n    print(`Two! ${x}, ${y}`);\n}\nfn foo() {\n    print(\"None.\");\n}\nfn foo(x) {     // &lt;- overwrites previous definition\n    print(`HA! NEW ONE! ${x}`);\n}\n\nfoo(1,2,3);     // prints \"Three!!! 1,2,3\"\n\nfoo(42);        // prints \"HA! NEW ONE! 42\"\n\nfoo(1,2);       // prints \"Two!! 1,2\"\n\nfoo();          // prints \"None.\"\n</code></pre>"},{"location":"functions/helpers/","title":"functions/helpers","text":"<p>Add description here\u2026</p>"},{"location":"functions/helpers/#contents","title":"Contents","text":"<p>Num Fn String Fn</p>"},{"location":"functions/helpers/num-fn/","title":"Numeric Functions","text":""},{"location":"functions/helpers/num-fn/#integer-functions","title":"Integer Functions","text":"<p>The following standard functions operate on integers only.</p> Function Description <code>is_odd</code> method and property returns <code>true</code> if the value is an odd number, otherwise <code>false</code> <code>is_even</code> method and property returns <code>true</code> if the value is an even number, otherwise <code>false</code> <code>min</code> returns the smaller of two numbers, the first number if equal <code>max</code> returns the larger of two numbers, the first number if equal <code>to_float</code> convert the value into <code>f64</code> (<code>f32</code> under 32-bit) <code>to_decimal</code> convert the value into decimal"},{"location":"functions/helpers/num-fn/#signed-numeric-functions","title":"Signed Numeric Functions","text":"<p>The following standard functions operate on signed numbers (including floating-point and decimal) only.</p> Function Description <code>abs</code> absolute value <code>sign</code> returns \u22121 if negative, +1 if positive, 0 if zero <code>is_zero</code> method and property returns <code>true</code> if the value is zero, otherwise <code>false</code>"},{"location":"functions/helpers/num-fn/#floating-point-functions","title":"Floating-Point Functions","text":"<p>The following standard functions operate on floating-point and decimal numbers only.</p> Category Decimal? Functions Trigonometry yes <code>sin</code>, <code>cos</code>, <code>tan</code> Trigonometry no <code>sinh</code>, <code>cosh</code>, <code>tanh</code> in radians, <code>hypot(</code>x<code>,</code>y<code>)</code> Arc-trigonometry no <code>asin</code>, <code>acos</code>, <code>atan(</code>v<code>)</code>, <code>atan(</code>x<code>,</code>y<code>)</code>, <code>asinh</code>, <code>acosh</code>, <code>atanh</code> in radians Square root yes <code>sqrt</code> Exponential yes <code>exp</code> (base e) Logarithmic yes <code>ln</code> (base e), <code>log</code> (base 10) Logarithmic no <code>log(</code>x<code>,</code>base<code>)</code> Rounding yes <code>floor</code>, <code>ceiling</code>, <code>round</code>, <code>int</code>, <code>fraction</code> methods and properties Conversion yes <code>to_int</code>, <code>to_decimal</code>, <code>to_float</code> Conversion no <code>to_degrees</code>, <code>to_radians</code> Comparison yes <code>min</code>, <code>max</code> (also inter-operates with integers) Testing no <code>is_nan</code>, <code>is_finite</code>, <code>is_infinite</code> methods and properties"},{"location":"functions/helpers/num-fn/#decimal-rounding-functions","title":"Decimal Rounding Functions","text":"<p>The following rounding methods operate on decimal numbers only.</p> Rounding type Behavior Methods None <code>floor</code>, <code>ceiling</code>, <code>int</code>, <code>fraction</code> methods and properties Banker's rounding round to integer <code>round</code> method and property Banker's rounding round to specified number of decimal points <code>round(</code>decimal points<code>)</code> Round up away from zero <code>round_up(</code>decimal points<code>)</code> Round down towards zero <code>round_down(</code>decimal points<code>)</code> Round half-up mid-point away from zero <code>round_half_up(</code>decimal points<code>)</code> Round half-down mid-point towards zero <code>round_half_down(</code>decimal points<code>)</code>"},{"location":"functions/helpers/num-fn/#parsing-functions","title":"Parsing Functions","text":"<p>The following standard functions parse numbers.</p> Function Description <code>parse_int</code> converts a string to integer with an optional radix <code>parse_float</code> converts a string to floating-point <code>parse_decimal</code> converts a string to decimal"},{"location":"functions/helpers/num-fn/#formatting-functions","title":"Formatting Functions","text":"<p>The following standard functions convert integer numbers into a string of hex, octal or binary representations. {{#.*}} | Function                  | Description                          | | ------------------------- | ------------------------------------ | | <code>to_binary</code> | converts an integer number to binary | | <code>to_octal</code>  | converts an integer number to octal  | | <code>to_hex</code>    | converts an integer number to hex    |</p>"},{"location":"functions/helpers/num-fn/#floating-point-constants","title":"Floating-point Constants","text":"<p>The following functions return standard mathematical constants.</p> Function Description <code>PI</code> returns the value of \u03c0 <code>E</code> returns the value of e"},{"location":"functions/helpers/string-fn/","title":"Standard String Functions","text":"<p>The following standard methods operate on strings (and possibly characters).</p> Function Parameter(s) Description <code>len</code> method and property none returns the number of characters (not number of bytes) in the string <code>bytes</code> method and property none returns the number of bytes making up the UTF-8 string; for strings containing only ASCII characters, this is much faster than <code>len</code> <code>is_empty</code> method and property none returns <code>true</code> if the string is empty <code>to_blob</code> none converts the string into an UTF-8 encoded byte-stream and returns it as a BLOB. <code>to_chars</code> none splits the string by individual characters, returning them as an array <code>get</code> position, counting from end if &lt; 0 gets the character at a certain position (<code>()</code> if the position is not valid) <code>set</code> <ol><li>position, counting from end if &lt; 0</li><li>new character</li></ol> sets a certain position to a new character (no effect if the position is not valid) <code>pad</code> <ol><li>target length</li><li>character/string to pad</li></ol> pads the string with a character or a string to at least a specified length <code>append</code>, <code>+=</code> operator item to append adds the display text of an item to the end of the string <code>remove</code> character/string to remove removes a character or a string from the string <code>pop</code> (optional) number of characters to remove, none if \u2264 0, entire string if \u2265 length removes the last character (if no parameter) and returns it (<code>()</code> if empty); otherwise, removes the last number of characters and returns them as a string <code>clear</code> none empties the string <code>truncate</code> target length cuts off the string at exactly a specified number of characters <code>to_upper</code> none converts the string/character into upper-case as a new string/character and returns it <code>to_lower</code> none converts the string/character into lower-case as a new string/character and returns it <code>make_upper</code> none converts the string/character into upper-case <code>make_lower</code> none converts the string/character into lower-case <code>trim</code> none trims the string of whitespace at the beginning and end <code>contains</code> character/sub-string to search for checks if a certain character or sub-string occurs in the string <code>starts_with</code> string returns <code>true</code> if the string starts with a certain string <code>ends_with</code> string returns <code>true</code> if the string ends with a certain string <code>min</code> <ol><li>first character/string</li><li>second character/string</li><ol> returns the smaller of two characters/strings <code>max</code> <ol><li>first character/string</li><li>second character/string</li><ol> returns the larger of two characters/strings <code>index_of</code> <ol><li>character/sub-string to search for</li><li>(optional) start position, counting from end if &lt; 0, end if \u2265 length</li></ol> returns the position that a certain character or sub-string occurs in the string, or \u22121 if not found <code>sub_string</code> <ol><li>start position, counting from end if &lt; 0</li><li>(optional) number of characters to extract, none if \u2264 0, to end if omitted</li></ol> extracts a sub-string <code>sub_string</code> range of characters to extract, from beginning if \u2264 0, to end if \u2265 length extracts a sub-string <code>split</code> none splits the string by whitespaces, returning an array of string segments <code>split</code> position to split at (in number of characters), counting from end if &lt; 0, end if \u2265 length splits the string into two segments at the specified character position, returning an array of two string segments <code>split</code> <ol><li>delimiter character/string</li><li>(optional) maximum number of segments, 1 if &lt; 1</li></ol> splits the string by the specified delimiter, returning an array of string segments <code>split_rev</code> <ol><li>delimiter character/string</li><li>(optional) maximum number of segments, 1 if &lt; 1</li></ol> splits the string by the specified delimiter in reverse order, returning an array of string segments <code>crop</code> <ol><li>start position, counting from end if &lt; 0</li><li>(optional) number of characters to retain, none if \u2264 0, to end if omitted</li></ol> retains only a portion of the string <code>crop</code> range of characters to retain, from beginning if \u2264 0, to end if \u2265 length retains only a portion of the string <code>replace</code> <ol><li>target character/sub-string</li><li>replacement character/string</li></ol> replaces a sub-string with another <code>chars</code> method and property <ol><li>(optional) start position, counting from end if &lt; 0</li><li>(optional) number of characters to iterate, none if \u2264 0</li></ol> allows iteration of the characters inside the string <p>Beware that functions that involve indexing into a string to get at individual characters, e.g. <code>sub_string</code>, require walking through the entire UTF-8 encoded bytes stream to extract individual Unicode characters and counting them, which can be slow for long strings.</p>"},{"location":"functions/helpers/string-fn/#building-strings","title":"Building Strings","text":"<p>strings can be built from segments via the <code>+</code> operator.</p> Operator Description string <code>+=</code> item convert the item into a string, then append it to the first string string <code>+</code> item convert the item into a string, then concatenate them as a new string item <code>+</code> string convert the item into a string, then concatenate them as a new string <pre><code>let x = 42;\n\n// Build string with '+'\nlet s = \"The answer is: \" + x + \"!!!\";\n\n// Prints: \"The answer is: 42!!!\"\nprint(s);\n</code></pre>"},{"location":"functions/helpers/string-fn/#standard-operators-between-strings-andor-characters","title":"Standard Operators Between Strings and/or Characters","text":"<p>The following standard operators inter-operate between strings and/or characters.</p> <p>When one (or both) of the operands is a character, it is first converted into a one-character string before running the operator.</p> Operator Description <code>+</code>, <code>+=</code> character/string concatenation <code>-</code>, <code>-=</code> remove [character](strings-chars.md/sub-string from string <code>==</code> equals to <code>!=</code> not equals to <code>&gt;</code> greater than <code>&gt;=</code> greater than or equals to <code>&lt;</code> less than <code>&lt;=</code> less than or equals to"},{"location":"functions/helpers/string-fn/#interop-with-blobs","title":"Interop with BLOB's","text":"<p>For convenience, when a BLOB is appended to a string, or vice versa, it is treated as a UTF-8 encoded byte stream and automatically first converted into the appropriate string value.</p> <p>That is because it is rarely useful to append a BLOB into a string, but extremely useful to be able to directly manipulate UTF-8 encoded text.</p> Operator Description <code>+</code>, <code>+=</code> append a BLOB (as a UTF-8 encoded byte stream) to the end of the string <code>+</code> concatenate a BLOB (as a UTF-8 encoded byte stream) with a string"},{"location":"functions/helpers/string-fn/#examples","title":"Examples","text":"<pre><code>let full_name == \" Bob C. Davis \";\nfull_name.len == 14;\n\nfull_name.trim();\nfull_name.len == 12;\nfull_name == \"Bob C. Davis\";\n\nfull_name.pad(15, '$');\nfull_name.len == 15;\nfull_name == \"Bob C. Davis$$$\";\n\nlet n = full_name.index_of('$');\nn == 12;\n\nfull_name.index_of(\"$$\", n + 1) == 13;\n\nfull_name.sub_string(n, 3) == \"$$$\";\nfull_name.sub_string(n..n+3) == \"$$$\";\n\nfull_name.truncate(6);\nfull_name.len == 6;\nfull_name == \"Bob C.\";\n\nfull_name.replace(\"Bob\", \"John\");\nfull_name.len == 7;\nfull_name == \"John C.\";\n\nfull_name.contains('C') == true;\nfull_name.contains(\"John\") == true;\n\nfull_name.crop(5);\nfull_name == \"C.\";\n\nfull_name.crop(0, 1);\nfull_name == \"C\";\n\nfull_name.clear();\nfull_name.len == 0;\n</code></pre>"},{"location":"meta/","title":"Meta / Utilities","text":"<p>Language metadata: comments, keywords, introspection, debug\u2010printing, timestamps.</p>"},{"location":"meta/#contents","title":"Contents","text":"<p>Comments Keywords Print Debug Type Of</p>"},{"location":"meta/comments/","title":"Comments","text":"<p>Comments are C-style, including <code>/*</code> ... <code>*/</code> pairs for block comments and <code>//</code> for comments to the end of the line.</p> <p>Block comments can be nested.</p> <pre><code>let /* intruder comment */ name = \"Bob\";\n\n// This is a very important one-line comment\n\n/* This comment spans\n   multiple lines, so it\n   only makes sense that\n   it is even more important */\n\n/* Fear not, AviScript satisfies all nesting needs with nested comments:\n   /*/*/*/*/**/*/*/*/*/\n*/\n</code></pre>"},{"location":"meta/comments/#doc-comments","title":"Doc-Comments","text":"<p>Comments starting with <code>///</code> (three slashes) or <code>/**</code> (two asterisks) are doc-comments.</p> <p>Doc-comments can only appear in front of function definitions, not any other elements.</p> <pre><code>/// This is a valid one-line doc-comment\nfn foo() {}\n\n/** This is a\n ** valid block\n ** doc-comment\n **/\nfn bar(x) {\n   /// Syntax error: this doc-comment is invalid\n   x + 1\n}\n\n/** Syntax error: this doc-comment is invalid */\nlet x = 42;\n\n/// Syntax error: this doc-comment is also invalid\n{\n   let x = 42;\n}\n</code></pre> <p>~~~admonish tip \"Tip: Special cases\"</p> <p>Long streams of <code>//////</code>... and <code>/*****</code>... do NOT form doc-comments. This is consistent with popular comment block styles for C-like languages.</p> <p><pre><code>///////////////////////////////  &lt;- this is not a doc-comment\n// This is not a doc-comment //  &lt;- this is not a doc-comment\n///////////////////////////////  &lt;- this is not a doc-comment\n\n// However, watch out for comment lines starting with '///'\n\n//////////////////////////////////////////  &lt;- this is not a doc-comment\n/// This, however, IS a doc-comment!!! ///  &lt;- doc-comment!\n//////////////////////////////////////////  &lt;- this is not a doc-comment\n\n/****************************************\n *                                      *\n * This is also not a doc-comment block *\n * so we don't have to put this in      *\n * front of a function.                 *\n *                                      *\n ****************************************/\n</code></pre> ~~~</p>"},{"location":"meta/comments/#module-documentation","title":"Module Documentation","text":"<p>Comment lines starting with <code>//!</code> make up the module documentation.</p> <p>They are used to document the containing module \u2013 or for a AviScript script file, to document the file itself.</p> <p>```rust //! Documentation for this script file. //! This script is used to calculate something and display the result.</p> <p>fn calculate(x) {    ... }</p> <p>fn display(msg) {    //! Module documentation can be placed anywhere within the file.    ... }</p> <p>//! All module documentation lines will be collected into a single block. ```</p> <p>For the example above, the module documentation block is:</p> <p><code>rust //! Documentation for this script file. //! This script is used to calculate something and display the result. //! Module documentation can be placed anywhere within the file. //! All module documentation lines will be collected into a single block.</code></p>"},{"location":"meta/keywords/","title":"Keywords","text":"<p>The following are reserved keywords in AviScript.</p> Active keywords Reserved keywords Usage <code>true</code>, <code>false</code> constants <code>let</code>, <code>const</code> <code>var</code>, <code>static</code> variables <code>is_shared</code> shared values <code>is</code> type checking <code>if</code>, <code>else</code> <code>goto</code> control flow <code>switch</code> <code>match</code>, <code>case</code> switching and matching <code>do</code>, <code>while</code>, <code>loop</code>, <code>until</code>, <code>for</code>, <code>in</code>, <code>continue</code>, <code>break</code> looping <code>fn</code>, <code>private</code>, <code>is_def_fn</code>, <code>this</code> <code>public</code>, <code>protected</code>, <code>new</code> functions <code>return</code> return values <code>throw</code>, <code>try</code>, <code>catch</code> throw/catch exceptions <code>import</code>, <code>export</code>, <code>as</code> <code>use</code>, <code>with</code>, <code>module</code>, <code>package</code>, <code>super</code> modules <code>global</code> automatic global module <code>Fn</code>, <code>call</code>, <code>curry</code> function pointers <code>spawn</code>, <code>thread</code>, <code>go</code>, <code>sync</code>, <code>async</code>, <code>await</code>, <code>yield</code> threading/async <code>type_of</code>, <code>print</code>, <code>debug</code>, <code>eval</code>, <code>is_def_var</code> special functions <code>default</code>, <code>void</code>, <code>null</code>, <code>nil</code> special values <p><code>admonish warning.small Keywords cannot become the name of a function or variable, even when they are disabled.</code></p>"},{"location":"meta/print-debug/","title":"<code>print</code> and <code>debug</code>","text":"<p>The <code>print</code> and <code>debug</code> functions can be used to output values.</p> <pre><code>print(\"hello\");         // prints \"hello\" to stdout\n\nprint(1 + 2 + 3);       // prints \"6\" to stdout\n\nlet x = 42;\n\nprint(`hello${x}`);     // prints \"hello42\" to stdout\n\ndebug(\"world!\");        // prints \"world!\" to stdout using debug formatting\n</code></pre>"},{"location":"meta/type-of/","title":"<code>type_of()</code>","text":"<p>The <code>type_of</code> function detects the actual type of a value.</p> <p>This is useful because all variables are dynamic in nature.</p> <pre><code>// Use 'type_of()' to get the actual types of values\ntype_of('c') == \"char\";\ntype_of(42) == \"i64\";\n\nlet x = 123;\nx.type_of() == \"i64\";       // method-call style is also OK\ntype_of(x) == \"i64\";\n\nx = 99.999;\ntype_of(x) == \"f64\";\n\nx = \"hello\";\nif type_of(x) == \"string\" {\n    do_something_first_with_string(x);\n}\n\nswitch type_of(x) {\n    \"string\" =&gt; do_something_with_string(x),\n    \"char\" =&gt; do_something_with_char(x),\n    \"i64\" =&gt; do_something_with_int(x),\n    \"f64\" =&gt; do_something_with_float(x),\n    \"bool\" =&gt; do_something_with_bool(x),\n    _ =&gt; throw `I cannot work with ${type_of(x)}!!!`\n}\n</code></pre> <p>```admonish info.small \"Standard types\"</p> <p>See here for the <code>type_of</code> output of standard types. ```</p>"},{"location":"modules/","title":"Modules","text":"<p>AviScript allows organizing code into modules.</p> <p>A module holds a collection of functions, constants and sub-modules.</p> <p>It may encapsulates a AviScript script together with the functions and constants defined by that script.</p> <p>Other scripts can then load this module and use the functions and constants exported as if they were defined inside the same script.</p>"},{"location":"modules/export/","title":"Export Variables, Functions and Sub-Modules From a Script","text":"<p>The easiest way to expose a collection of functions as a self-contained module is to do it via a AviScript script itself.</p> <p>The script text is evaluated.</p> <p>Variables are then selectively exposed via the <code>export</code> statement.</p> <p>Functions defined by the script are automatically exported, unless marked as <code>private</code>.</p> <p>Modules loaded within this module at the global level become sub-modules and are also automatically exported.</p>"},{"location":"modules/export/#export-global-constants","title":"Export Global Constants","text":"<p>The <code>export</code> statement, which can only be at global level, exposes a selected variable as member of a module.</p> <p>Variables not exported are private and hidden. They are merely used to initialize the module, but cannot be accessed from outside.</p> <p>Everything exported from a module is constant (i.e. read-only).</p> <pre><code>// This is a module script.\n\nlet hidden = 123;       // variable not exported - default hidden\nlet x = 42;             // this will be exported below\n\nexport x;               // the variable 'x' is exported under its own name\n\nexport const x = 42;    // convenient short-hand to declare a constant and export it\n                        // under its own name\n\nexport let x = 123;     // variables can be exported as well, though it'll still be constant\n\nexport x as answer;     // the variable 'x' is exported under the alias 'answer'\n                        // another script can load this module and access 'x' as 'module::answer'\n\n{\n    let inner = 0;      // local variable - it disappears when the statements block ends,\n                        //                  therefore it is not 'global' and cannot be exported\n\n    export inner;       // &lt;- syntax error: cannot export a local variable\n}\n</code></pre> <p>```admonish tip.small \"Tip: Multiple exports\"</p> <p>[Variables] can be exported under multiple names. For example, the following exports three [variables]: * <code>x</code> as <code>x</code> and <code>hello</code> * <code>y</code> as <code>foo</code> and <code>bar</code> * <code>z</code> as <code>z</code></p> <p><pre><code>export x;\nexport x as hello;\nexport y as foo;\nexport x as world;\nexport y as bar;\nexport z;\n</code></pre> <pre><code>Export Functions\n----------------\n\n```admonish info.side.wide \"Private functions\"\n\n`private` [functions](../functions.md) are commonly called within the [module](modules/index.md) only.\nThey cannot be accessed otherwise.\n</code></pre></p> <p>All functions are automatically exported, unless it is explicitly opt-out with the <code>private</code> prefix.</p> <p>Functions declared <code>private</code> are hidden to the outside.</p> <pre><code>// This is a module script.\n\nfn inc(x) { x + 1 }     // script-defined function - default public\n\nprivate fn foo() {}     // private function - hidden\n</code></pre>"},{"location":"modules/export/#sub-modules","title":"Sub-Modules","text":"<p>All loaded modules are automatically exported as sub-modules.</p> <p>~~~admonish tip.small \"Tip: Skip exporting a module\"</p> <p>To prevent a module from being exported, load it inside a block statement so that it goes away at the end of the block.</p> <p><pre><code>// This is a module script.\n\nimport \"hello\" as foo;      // &lt;- exported\n\n{\n    import \"world\" as bar;  // &lt;- not exported\n}\n</code></pre> ~~~</p>"},{"location":"modules/import/","title":"Import a Module","text":""},{"location":"modules/import/#import-statement","title":"<code>import</code> Statement","text":"<p>```admonish tip.side.wide \"Tip\"</p> <p>A module that is only <code>import</code>-ed but not given any name is simply run.</p> <p>This is a very simple way to run another script file from within a script. <pre><code>A [module](modules/index.md) can be _imported_ via the `import` statement, and be given a name.\n\nIts members can be accessed via `::` similar to C++.\n\n```js\nimport \"crypto_banner\";         // run the script file 'crypto_banner.avi' without creating an imported module\n\nimport \"crypto\" as lock;        // run the script file 'crypto.avi' and import it as a module named 'lock'\n\nconst SECRET_NUMBER = 42;\n\nlet mod_file = `crypto_${SECRET_NUMBER}`;\n\nimport mod_file as my_mod;      // load the script file \"crypto_42.avi\" and import it as a module named 'my_mod'\n                                // notice that module path names can be dynamically constructed!\n                                // any expression that evaluates to a string is acceptable after the 'import' keyword\n\nlock::encrypt(secret);          // use functions defined under the module via '::'\n\nlock::hash::sha256(key);        // sub-modules are also supported\n\nprint(lock::status);            // module variables are constants\n\nlock::status = \"off\";           // &lt;- runtime error: cannot modify a constant\n</code></pre></p> <p>```admonish info \"Imports are scoped\"</p> <p>Modules imported via <code>import</code> statements are only accessible inside the relevant block scope.</p> <p><pre><code>import \"hacker\" as h;           // import module - visible globally\n\nif secured {                    // &lt;- new block scope\n    let mod = \"crypt\";\n\n    import mod + \"o\" as c;      // import module (the path needs not be a constant string)\n\n    let x = c::encrypt(key);    // use a function in the module\n\n    h::hack(x);                 // global module 'h' is visible here\n}                               // &lt;- module 'c' disappears at the end of the block scope\n\nh::hack(something);             // this works as 'h' is visible\n\nc::encrypt(something);          // &lt;- this causes a run-time error because\n                                //    module 'c' is no longer available!\n\nfn foo(something) {\n    h::hack(something);         // &lt;- this also works as 'h' is visible\n}\n\nfor x in 0..1000 {\n    import \"crypto\" as c;       // &lt;- importing a module inside a loop is a Very Bad Idea\u2122\n\n    c.encrypt(something);\n}\n</code></pre> <pre><code>~~~admonish note \"Place `import` statements at the top\"\n\n`import` statements can appear anywhere a normal statement can be, but in the vast majority of cases they are\nusually grouped at the top (beginning) of a script for manageability and visibility.\n\nIt is not advised to deviate from this common practice unless there is a _Very Good Reason\u2122_.\n\nEspecially, do not place an `import` statement within a loop; doing so will repeatedly re-load the\nsame [module](modules/index.md) during every iteration of the loop!\n~~~\n\n~~~admonish danger \"Recursive imports\"\n\nBeware of _import cycles_ &amp;ndash; i.e. recursively loading the same [module](modules/index.md).\nThis is a sure-fire way to cause a stack overflow error.\n\nFor instance, importing itself always causes an infinite recursion:\n\n```js\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 hello.avi \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nimport \"hello\" as foo;          // import itself - infinite recursion!\n\nfoo::do_something();\n</code></pre></p> <p>Modules cross-referencing also cause infinite recursion:</p> <p><pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 hello.avi \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nimport \"world\" as foo;\nfoo::do_something();\n\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 world.avi \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nimport \"hello\" as bar;\nbar::do_something_else();\n</code></pre> ~~~</p>"},{"location":"modules/builtin/","title":"Built\u2011in Modules","text":"<p>Core, built\u2011in modules provided by the runtime.</p>"},{"location":"modules/builtin/#contents","title":"Contents","text":"<p>Ask Assets Config Context Http Speak Translation</p>"},{"location":"modules/builtin/ask/","title":"Ask Module","text":"<p>The <code>ask</code> module provides functions for gathering input from users in your AviScript skills.</p>"},{"location":"modules/builtin/ask/#functions","title":"Functions","text":""},{"location":"modules/builtin/ask/#askquestionkey-callback-context-expected","title":"<code>ask.question(key, callback, context, expected)</code>","text":"<p>Asks a question using a translation key and calls the callback when the user responds.</p> <p>Parameters: - <code>key</code>: Translation key for the question - <code>callback</code>: Function to call with the user's response - <code>context</code>: Map of placeholder values for the question text - <code>expected</code>: Expected input type or validation criteria</p> <pre><code>ask.question(\"ask_name\", |response| {\n    context.save(\"user_name\", response);\n    speak.say(\"greeting\", #{ \"name\": response });\n}, #{}, \"text\");\n</code></pre>"},{"location":"modules/builtin/ask/#askon_inputcallback-expected","title":"<code>ask.on_input(callback, expected)</code>","text":"<p>Sets up a handler for the next user input.</p> <p>Parameters: - <code>callback</code>: Function to call with the user's input - <code>expected</code>: Expected input type or validation criteria</p> <pre><code>speak.text(\"What would you like to do next?\");\nask.on_input(|input| {\n    if input.contains(\"weather\") {\n        // Handle weather intent\n    } else if input.contains(\"news\") {\n        // Handle news intent\n    } else {\n        speak.text(\"I didn't understand that.\");\n    }\n}, \"text\");\n</code></pre>"},{"location":"modules/builtin/ask/#askconfirmcallback","title":"<code>ask.confirm(callback)</code>","text":"<p>Asks for a yes/no confirmation and calls the callback with the result.</p> <p>Parameter: - <code>callback</code>: Function to call with boolean result (true for yes, false for no)</p> <pre><code>speak.text(\"Are you sure you want to delete your profile?\");\nask.confirm(|confirmed| {\n    if confirmed {\n        // Delete profile\n        speak.text(\"Your profile has been deleted.\");\n    } else {\n        speak.text(\"Operation cancelled.\");\n    }\n});\n</code></pre>"},{"location":"modules/builtin/ask/#askcancelcallback","title":"<code>ask.cancel(callback)</code>","text":"<p>Sets up a handler for if the user cancels the current interaction.</p> <p>Parameter: - <code>callback</code>: Function to call when user cancels</p> <pre><code>ask.cancel(|| {\n    speak.text(\"No problem, we can do this later.\");\n    context.save(\"setup_completed\", false);\n});\n</code></pre>"},{"location":"modules/builtin/ask/#asknumber_inputprompt-callback","title":"<code>ask.number_input(prompt, callback)</code>","text":"<p>Asks specifically for a number input.</p> <p>Parameters: - <code>prompt</code>: Text prompt for the number input - <code>callback</code>: Function to call with the number response</p> <pre><code>ask.number_input(\"How many tickets would you like to purchase?\", |count| {\n    if count &gt; 0 &amp;&amp; count &lt;= 10 {\n        context.save(\"ticket_count\", count);\n        speak.text(\"Added \" + count + \" tickets to your cart.\");\n    } else {\n        speak.text(\"Sorry, you can only purchase between 1 and 10 tickets.\");\n    }\n});\n</code></pre>"},{"location":"modules/builtin/ask/#example-usage","title":"Example Usage","text":"<pre><code>on_intent \"book_flight\" {\n    // Ask for destination\n    ask.question(\"ask_destination\", |destination| {\n        context.save(\"flight_destination\", destination);\n\n        // Ask for date\n        ask.question(\"ask_travel_date\", |date| {\n            context.save(\"flight_date\", date);\n\n            // Confirm booking\n            speak.say(\"confirm_booking\", #{ \n                \"destination\": destination,\n                \"date\": date\n            });\n\n            ask.confirm(|confirmed| {\n                if confirmed {\n                    // Process booking\n                    speak.say(\"booking_confirmed\", #{});\n                } else {\n                    speak.say(\"booking_cancelled\", #{});\n                }\n            });\n        }, #{}, \"date\");\n    }, #{}, \"text\");\n\n    // Set up cancel handler\n    ask.cancel(|| {\n        speak.say(\"booking_process_cancelled\", #{});\n    });\n}\n</code></pre>"},{"location":"modules/builtin/ask/#best-practices","title":"Best Practices","text":"<ol> <li>Always provide clear prompts for what kind of input you expect</li> <li>Handle unexpected inputs gracefully</li> <li>Use appropriate input types (text, number, confirmation)</li> <li>Always provide a cancel handler for multi-step interactions</li> <li>Save user responses to context for later use</li> </ol>"},{"location":"modules/builtin/assets/","title":"Assets Module","text":"<p>The <code>assets</code> module provides functions for accessing and managing skill assets like files, images, and audio in your AviScript skills.</p>"},{"location":"modules/builtin/assets/#file-functions","title":"File Functions","text":""},{"location":"modules/builtin/assets/#assetsgetfile","title":"<code>assets.get(file)</code>","text":"<p>Gets the full path to an asset file.</p> <p>Parameter: - <code>file</code>: Relative path to the asset file</p> <p>Returns: - <code>String</code>: Full path to the asset file</p> <pre><code>let image_path = assets.get(\"images/logo.png\");\n</code></pre>"},{"location":"modules/builtin/assets/#assetsexistsfile","title":"<code>assets.exists(file)</code>","text":"<p>Checks if an asset file exists.</p> <p>Parameter: - <code>file</code>: Relative path to the asset file</p> <p>Returns: - <code>bool</code>: True if the file exists, false otherwise</p> <pre><code>if assets.exists(\"data/user_preferences.json\") {\n    // Use the file\n} else {\n    // Create default preferences\n}\n</code></pre>"},{"location":"modules/builtin/assets/#assetsread_textfile","title":"<code>assets.read_text(file)</code>","text":"<p>Reads a text file and returns its contents as a string.</p> <p>Parameter: - <code>file</code>: Relative path to the text file</p> <p>Returns: - <code>String</code>: Contents of the file</p> <pre><code>let instructions = assets.read_text(\"instructions.txt\");\nspeak.text(instructions);\n</code></pre>"},{"location":"modules/builtin/assets/#assetsread_jsonfile","title":"<code>assets.read_json(file)</code>","text":"<p>Reads a JSON file and returns its parsed contents as a map.</p> <p>Parameter: - <code>file</code>: Relative path to the JSON file</p> <p>Returns: - <code>Map</code>: Parsed JSON content</p> <pre><code>let config = assets.read_json(\"config/settings.json\");\nlet timeout = config[\"timeout\"] or 30;\n</code></pre>"},{"location":"modules/builtin/assets/#audio-submodule","title":"Audio Submodule","text":"<p>The <code>assets.audio</code> submodule provides functions for playing and controlling audio files.</p>"},{"location":"modules/builtin/assets/#assetsaudioplayfile","title":"<code>assets.audio.play(file)</code>","text":"<p>Plays an audio file.</p> <p>Parameter: - <code>file</code>: Relative path to the audio file</p> <pre><code>assets.audio.play(\"sounds/notification.mp3\");\n</code></pre>"},{"location":"modules/builtin/assets/#assetsaudiostop","title":"<code>assets.audio.stop()</code>","text":"<p>Stops the currently playing audio.</p> <pre><code>assets.audio.stop();\n</code></pre>"},{"location":"modules/builtin/assets/#assetsaudiois_playing","title":"<code>assets.audio.is_playing()</code>","text":"<p>Checks if audio is currently playing.</p> <p>Returns: - <code>bool</code>: True if audio is playing, false otherwise</p> <pre><code>if assets.audio.is_playing() {\n    assets.audio.stop();\n}\n</code></pre>"},{"location":"modules/builtin/assets/#assetsaudiovolumelevel","title":"<code>assets.audio.volume(level)</code>","text":"<p>Sets the audio volume level.</p> <p>Parameter: - <code>level</code>: Volume level (0-100)</p> <pre><code>assets.audio.volume(75);  // Set volume to 75%\n</code></pre>"},{"location":"modules/builtin/assets/#assetsaudiomute","title":"<code>assets.audio.mute()</code>","text":"<p>Mutes the audio.</p> <pre><code>assets.audio.mute();\n</code></pre>"},{"location":"modules/builtin/assets/#assetsaudiounmute","title":"<code>assets.audio.unmute()</code>","text":"<p>Unmutes the audio.</p> <pre><code>assets.audio.unmute();\n</code></pre>"},{"location":"modules/builtin/assets/#example-usage","title":"Example Usage","text":"<pre><code>on_intent \"play_tutorial\" {\n    // Check if tutorial exists\n    if assets.exists(\"tutorials/beginner.mp3\") {\n        speak.text(\"Playing the beginner tutorial now.\");\n\n        // Set volume and play\n        assets.audio.volume(80);\n        assets.audio.play(\"tutorials/beginner.mp3\");\n\n        // Display accompanying image\n\n        // Load supplementary text\n        let tips = assets.read_text(\"tutorials/beginner_tips.txt\");\n        context.save(\"current_tips\", tips);\n    } else {\n        speak.text(\"Sorry, the tutorial isn't available.\");\n    }\n}\n</code></pre>"},{"location":"modules/builtin/assets/#best-practices","title":"Best Practices","text":"<ol> <li>Always check if files exist before attempting to use them</li> <li>Use appropriate file formats for different asset types</li> <li>Keep audio files short and high-quality</li> <li>Organize assets in a logical directory structure</li> <li>Use volume controls responsibly to prevent jarring audio experiences</li> </ol>"},{"location":"modules/builtin/config/","title":"Config Module","text":"<p>The <code>config</code> module provides functions for accessing and managing skill configuration settings in your AviScript skills.</p>"},{"location":"modules/builtin/config/#config-management-functions","title":"Config Management Functions","text":""},{"location":"modules/builtin/config/#configgetname","title":"<code>config.get(name)</code>","text":"<p>Gets a configuration value by name.</p> <p>Parameter: - <code>name</code>: Configuration key name</p> <p>Returns: - <code>Dynamic</code>: The configuration value</p> <pre><code>let timeout = config.get(\"request_timeout\");\n</code></pre>"},{"location":"modules/builtin/config/#configsetname-value","title":"<code>config.set(name, value)</code>","text":"<p>Sets a configuration value.</p> <p>Parameters: - <code>name</code>: Configuration key name - <code>value</code>: Value to set</p> <pre><code>config.set(\"user_preferences.theme\", \"dark\");\n</code></pre>"},{"location":"modules/builtin/config/#confighasname","title":"<code>config.has(name)</code>","text":"<p>Checks if a configuration key exists.</p> <p>Parameter: - <code>name</code>: Configuration key name</p> <p>Returns: - <code>bool</code>: True if the configuration exists, false otherwise</p> <pre><code>if config.has(\"api_key\") {\n    // Use the API key\n} else {\n    speak.text(\"Please configure your API key first.\");\n}\n</code></pre>"},{"location":"modules/builtin/config/#configtype_ofname","title":"<code>config.type_of(name)</code>","text":"<p>Gets the data type of a configuration value.</p> <p>Parameter: - <code>name</code>: Configuration key name</p> <p>Returns: - <code>String</code>: Type name (\"string\", \"int\", \"float\", \"bool\", \"list\", \"map\")</p> <pre><code>let value_type = config.type_of(\"max_results\");\nif value_type == \"int\" {\n    // Handle integer config\n} else if value_type == \"string\" {\n    // Handle string config\n}\n</code></pre>"},{"location":"modules/builtin/config/#configconstantname","title":"<code>config.constant(name)</code>","text":"<p>Gets a constant value by name.</p> <p>Parameter: - <code>name</code>: Constant name</p> <p>Returns: - <code>String</code>: The constant value</p> <pre><code>let api_endpoint = config.constant(\"API_ENDPOINT\");\n</code></pre>"},{"location":"modules/builtin/config/#configuration-file-structure","title":"Configuration File Structure","text":"<p>Configurations are typically stored in <code>skill.config</code> in your skill directory, structured as a JSON file with a <code>configs</code> and <code>constants</code> section:</p> <pre><code>{\n  \"configs\": {\n    \"request_timeout\": {\n      \"value\": 30,\n      \"default\": 30,\n      \"type\": \"int\",\n      \"label\": \"Request Timeout\",\n      \"description\": \"Timeout in seconds for API requests\"\n    },\n    \"max_results\": {\n      \"value\": 5,\n      \"default\": 5,\n      \"type\": \"int\",\n      \"label\": \"Maximum Results\",\n      \"description\": \"Maximum number of results to display\"\n    }\n  },\n  \"constants\": {\n    \"API_ENDPOINT\": \"https://api.example.com/v1\",\n    \"VERSION\": \"1.0.0\",\n    \"DEBUG_MODE\": false\n  }\n}\n</code></pre>"},{"location":"modules/builtin/config/#example-usage","title":"Example Usage","text":"<pre><code>on_start {\n    // Check and validate configurations\n    if !config.has(\"api_key\") {\n        speak.text(\"API key not configured. Some features may not work.\");\n    }\n\n    // Get and use configs with defaults\n    let timeout = 30;\n    if config.has(\"request_timeout\") {\n        timeout = config.get(\"request_timeout\");\n    }\n\n    // Use constants\n    let version = config.constant(\"VERSION\");\n    speak.text(\"Running skill version \" + version);\n\n    // Save the timeout to context for later use\n    context.save(\"current_timeout\", timeout);\n}\n\non_intent \"change_settings\" {\n    let setting_type = intent.get(\"setting_type\");\n    let new_value = intent.get(\"setting_value\");\n\n    if setting_type == \"timeout\" {\n        if config.type_of(\"request_timeout\") == \"int\" {\n            // Convert string to number\n            let timeout_value = parse_int(new_value);\n            config.set(\"request_timeout\", timeout_value);\n            speak.say(\"setting_updated\", #{ \"setting\": \"timeout\", \"value\": new_value });\n        }\n    } else if setting_type == \"theme\" {\n        config.set(\"theme\", new_value);\n        speak.say(\"setting_updated\", #{ \"setting\": \"theme\", \"value\": new_value });\n    }\n}\n</code></pre>"},{"location":"modules/builtin/config/#best-practices","title":"Best Practices","text":"<ol> <li>Always provide sensible default values</li> <li>Check if configurations exist before using them</li> <li>Validate configuration types and values</li> <li>Use constants for values that shouldn't change at runtime</li> <li>Organize related configurations using dot notation (e.g., \"audio.volume\", \"audio.quality\")</li> <li>Include descriptive labels and descriptions in your config file</li> </ol>"},{"location":"modules/builtin/context/","title":"Context Module","text":"<p>The <code>context</code> module provides functions for storing and retrieving state information across interactions in your AviScript skills.</p>"},{"location":"modules/builtin/context/#context-management-functions","title":"Context Management Functions","text":""},{"location":"modules/builtin/context/#contextsavename-value","title":"<code>context.save(name, value)</code>","text":"<p>Saves a value to the context with the specified name.</p> <p>Parameters: - <code>name</code>: Context key name - <code>value</code>: Value to save</p> <pre><code>context.save(\"last_search\", \"weather in Paris\");\ncontext.save(\"user_preferences\", #{ \"theme\": \"dark\", \"voice\": \"female_1\" });\n</code></pre>"},{"location":"modules/builtin/context/#contextloadname","title":"<code>context.load(name)</code>","text":"<p>Loads a value from the context by name.</p> <p>Parameter: - <code>name</code>: Context key name</p> <p>Returns: - <code>Dynamic</code>: The stored value or <code>()</code> (null) if not found</p> <pre><code>let last_search = context.load(\"last_search\");\nif last_search != () {\n    speak.text(\"Your last search was: \" + last_search);\n}\n</code></pre>"},{"location":"modules/builtin/context/#contextclearname","title":"<code>context.clear(name)</code>","text":"<p>Removes a value from the context.</p> <p>Parameter: - <code>name</code>: Context key name</p> <pre><code>context.clear(\"temporary_data\");\n</code></pre>"},{"location":"modules/builtin/context/#context-persistence","title":"Context Persistence","text":"<p>Context data is maintained across interactions within a session. Some implementations may persist certain context data between sessions, but this should not be assumed unless specifically documented.</p>"},{"location":"modules/builtin/context/#example-usage","title":"Example Usage","text":"<pre><code>on_start {\n    // Load user preferences from previous sessions\n    let visits = context.load(\"visit_count\") or 0;\n    visits += 1;\n    context.save(\"visit_count\", visits);\n\n    if visits == 1 {\n        speak.say(\"first_time_greeting\", #{});\n        // Save default preferences\n        context.save(\"preferences\", #{ \"theme\": \"light\", \"notifications\": true });\n    } else {\n        speak.say(\"return_greeting\", #{ \"count\": visits });\n        // Load existing preferences\n        let prefs = context.load(\"preferences\");\n        if prefs != () {\n            // Apply preferences\n            if prefs[\"theme\"] == \"dark\" {\n                // Apply dark theme\n            }\n        }\n    }\n}\n\non_intent \"update_preference\" {\n    let pref_name = intent.require(\"preference_name\");\n    let pref_value = intent.require(\"preference_value\");\n\n    // Load current preferences\n    let prefs = context.load(\"preferences\") or #{};\n\n    // Update specific preference\n    prefs[pref_name] = pref_value;\n\n    // Save updated preferences\n    context.save(\"preferences\", prefs);\n\n    speak.say(\"preference_updated\", #{ \"name\": pref_name, \"value\": pref_value });\n}\n\non_intent \"clear_history\" {\n    // Clear sensitive context data\n    context.clear(\"search_history\");\n    context.clear(\"last_search\");\n\n    // Keep preferences\n    speak.say(\"history_cleared\", #{});\n}\n</code></pre>"},{"location":"modules/builtin/context/#context-namespacing","title":"Context Namespacing","text":"<p>It's a good practice to namespace your context keys to avoid conflicts with other skills:</p> <pre><code>// Instead of generic keys\ncontext.save(\"user\", user_data);\n\n// Use namespaced keys\ncontext.save(\"myskill.user\", user_data);\n</code></pre>"},{"location":"modules/builtin/context/#best-practices","title":"Best Practices","text":"<ol> <li>Use context to maintain state between interactions</li> <li>Clear temporary or sensitive data when no longer needed</li> <li>Use namespace prefixes for context keys to avoid conflicts</li> <li>Always provide fallback values when loading context</li> <li>Keep context data size reasonable</li> <li>Don't store sensitive information like passwords or tokens in context</li> <li>Use structured data (maps) to group related context values</li> <li>Consider context persistence when designing your skill</li> </ol>"},{"location":"modules/builtin/http/","title":"Http Module","text":"<p>The <code>http</code> module provides functions for making HTTP requests to external services from your AviScript skills.</p>"},{"location":"modules/builtin/http/#http-request-functions","title":"HTTP Request Functions","text":""},{"location":"modules/builtin/http/#httpcallroute-method-params","title":"<code>http.call(route, method, params)</code>","text":"<p>Makes an HTTP request with the specified method and parameters.</p> <p>Parameters: - <code>route</code>: URL or endpoint path - <code>method</code>: HTTP method (GET, POST, PUT, DELETE, etc.) - <code>params</code>: Map of parameters or body data</p> <p>Returns: - <code>Dynamic</code>: Response data, typically parsed from JSON</p> <pre><code>let response = http.call(\"https://api.example.com/data\", \"GET\", #{ \"id\": 123 });\n</code></pre>"},{"location":"modules/builtin/http/#httpgetroute-params","title":"<code>http.get(route, params)</code>","text":"<p>Makes an HTTP GET request.</p> <p>Parameters: - <code>route</code>: URL or endpoint path - <code>params</code>: Map of query parameters</p> <p>Returns: - <code>Dynamic</code>: Response data, typically parsed from JSON</p> <pre><code>let weather_data = http.get(\"/api/weather\", #{ \n    \"location\": \"London\", \n    \"units\": \"metric\" \n});\n\nspeak.text(\"The temperature is \" + weather_data[\"temperature\"] + \" degrees\");\n</code></pre>"},{"location":"modules/builtin/http/#httppostroute-body","title":"<code>http.post(route, body)</code>","text":"<p>Makes an HTTP POST request.</p> <p>Parameters: - <code>route</code>: URL or endpoint path - <code>body</code>: Map of data to send in the request body</p> <p>Returns: - <code>Dynamic</code>: Response data, typically parsed from JSON</p> <pre><code>let result = http.post(\"/api/users\", #{ \n    \"name\": \"Alice Smith\", \n    \"email\": \"alice@example.com\" \n});\n\nif result[\"success\"] {\n    speak.text(\"User created successfully\");\n} else {\n    speak.text(\"Failed to create user: \" + result[\"error\"]);\n}\n</code></pre>"},{"location":"modules/builtin/http/#httpstatus","title":"<code>http.status()</code>","text":"<p>Gets the status code of the last HTTP request.</p> <p>Returns: - <code>int</code>: HTTP status code</p> <pre><code>let data = http.get(\"/api/products\", #{ \"category\": \"electronics\" });\n\nif http.status() == 200 {\n    // Handle successful response\n    speak.text(\"Found \" + data[\"count\"] + \" products\");\n} else if http.status() == 404 {\n    speak.text(\"No products found in that category\");\n} else {\n    speak.text(\"Error fetching products: \" + http.status());\n}\n</code></pre>"},{"location":"modules/builtin/http/#error-handling","title":"Error Handling","text":"<p>HTTP requests can fail for various reasons. Always check the status code or handle errors appropriately:</p> <pre><code>let response = http.get(\"/api/data\", #{ \"id\": user_id });\n\nif http.status() &gt;= 400 {\n    speak.say(\"api_error\", #{ \"status\": http.status() });\n    return;\n}\n\n// Process successful response\n</code></pre>"},{"location":"modules/builtin/http/#example-usage","title":"Example Usage","text":"<pre><code>on_intent \"get_weather_forecast\" {\n    let location = intent.require(\"location\");\n    let days = intent.optional(\"days\", 1);\n\n    speak.say(\"fetching_weather\", #{ \"location\": location });\n\n    // Make API request\n    let weather = http.get(\"https://weather-api.example.com/forecast\", #{ \n        \"location\": location, \n        \"days\": days \n    });\n\n    // Check for errors\n    if http.status() != 200 {\n        speak.say(\"weather_error\", #{ \"status\": http.status() });\n        return;\n    }\n\n    // Process and present the data\n    let forecast = weather[\"forecast\"];\n    let summary = weather[\"summary\"];\n\n    speak.say(\"weather_report\", #{ \n        \"location\": location,\n        \"summary\": summary,\n        \"temperature\": forecast[\"temperature\"],\n        \"conditions\": forecast[\"conditions\"]\n    });\n\n    // Save the request for later reference\n    context.save(\"last_weather_location\", location);\n}\n</code></pre>"},{"location":"modules/builtin/http/#best-practices","title":"Best Practices","text":"<ol> <li>Always handle HTTP errors gracefully</li> <li>Use HTTPS URLs for security</li> <li>Cache responses when appropriate to reduce API calls</li> <li>Implement rate limiting for frequent requests</li> <li>Keep authentication credentials secure</li> <li>Structure API endpoints consistently</li> <li>Use appropriate HTTP methods for different operations</li> <li>Include timeout handling for slow responses</li> <li>Log</li> </ol>"},{"location":"modules/builtin/speak/","title":"Speak Module","text":"<p>The <code>speak</code> module provides functions for text-to-speech, voice control, and managing speech output in your AviScript skills.</p>"},{"location":"modules/builtin/speak/#functions","title":"Functions","text":""},{"location":"modules/builtin/speak/#basic-speech","title":"Basic Speech","text":""},{"location":"modules/builtin/speak/#speaksaykey-context","title":"<code>speak.say(key, context)</code>","text":"<p>Speaks a translated message using a translation key and context for placeholders.</p> <pre><code>speak.say(\"greeting\", #{ \"name\": \"Alex\" });  // Says the translated greeting with the name Alex\n</code></pre>"},{"location":"modules/builtin/speak/#speaktextmessage","title":"<code>speak.text(message)</code>","text":"<p>Speaks a literal text message without translation.</p> <pre><code>speak.text(\"Hello, how can I help you today?\");\n</code></pre>"},{"location":"modules/builtin/speak/#speaktranslatedkey-context","title":"<code>speak.translated(key, context)</code>","text":"<p>Similar to <code>say()</code>, but with different processing (implementation details may vary).</p> <pre><code>speak.translated(\"farewell\", #{ \"time\": \"evening\" });\n</code></pre>"},{"location":"modules/builtin/speak/#voice-controls","title":"Voice Controls","text":""},{"location":"modules/builtin/speak/#speakvoicename","title":"<code>speak.voice(name)</code>","text":"<p>Changes the voice used for speech output.</p> <pre><code>speak.voice(\"female_1\");\nspeak.text(\"This is spoken in a female voice\");\n\nspeak.voice(\"male_2\");\nspeak.text(\"Now I'm using a male voice\");\n</code></pre>"},{"location":"modules/builtin/speak/#speakrepeat","title":"<code>speak.repeat()</code>","text":"<p>Repeats the last spoken message.</p> <pre><code>speak.text(\"This is important information\");\n// Later in the skill\nspeak.repeat();  // Repeats \"This is important information\"\n</code></pre>"},{"location":"modules/builtin/speak/#speakpauseseconds","title":"<code>speak.pause(seconds)</code>","text":"<p>Inserts a pause of specified duration in seconds.</p> <pre><code>speak.text(\"I'll give you a moment to think about that.\");\nspeak.pause(3);  // Pause for 3 seconds\nspeak.text(\"Now, let's continue.\");\n</code></pre>"},{"location":"modules/builtin/speak/#example-usage","title":"Example Usage","text":"<pre><code>on_intent \"welcome_user\" {\n    let user_name = intent.optional(\"name\", \"friend\");\n\n    // Set voice based on user preference\n    let voice_pref = context.load(\"voice_preference\") or \"default\";\n    speak.voice(voice_pref);\n\n    // Greet the user\n    speak.say(\"welcome\", #{ \"name\": user_name });\n    speak.pause(1);\n\n    // Provide instructions\n    speak.say(\"help_prompt\", #{});\n}\n</code></pre>"},{"location":"modules/builtin/speak/#best-practices","title":"Best Practices","text":"<ol> <li>Use translation keys with <code>speak.say()</code> rather than hardcoded text to support multiple languages</li> <li>Provide context objects with placeholders for dynamic content</li> <li>Use pauses strategically to make conversation feel more natural</li> <li>Change voices only when it adds value to the user experience</li> <li>Keep utterances concise and clear</li> </ol>"},{"location":"modules/builtin/translation/","title":"Translation Module","text":"<p>The <code>translation</code> module provides functions for accessing and managing translations in your AviScript skills, enabling multi-language support.</p>"},{"location":"modules/builtin/translation/#translation-functions","title":"Translation Functions","text":""},{"location":"modules/builtin/translation/#translationgetkey-context","title":"<code>translation.get(key, context)</code>","text":"<p>Gets a translated string by key, with placeholder replacements.</p> <p>Parameters: - <code>key</code>: Translation key - <code>context</code>: Map of placeholder values</p> <p>Returns: - <code>String</code>: Translated text with placeholders replaced</p> <pre><code>let greeting = translation.get(\"welcome_user\", #{ \"name\": \"Alex\" });\n// Might return: \"Welcome, Alex!\" or \"Bienvenido, Alex!\" depending on language\n</code></pre>"},{"location":"modules/builtin/translation/#translationget_rawkey","title":"<code>translation.get_raw(key)</code>","text":"<p>Gets a translated string by key without any formatting.</p> <p>Parameter: - <code>key</code>: Translation key</p> <p>Returns: - <code>String</code>: Raw translated text</p> <pre><code>let raw_text = translation.get_raw(\"welcome_message\");\n// Might return: \"Welcome to our service, {user}!\"\n</code></pre>"},{"location":"modules/builtin/translation/#translationexistskey","title":"<code>translation.exists(key)</code>","text":"<p>Checks if a translation key exists.</p> <p>Parameter: - <code>key</code>: Translation key</p> <p>Returns: - <code>bool</code>: True if the translation exists, false otherwise</p> <pre><code>if translation.exists(\"advanced_feature_description\") {\n    speak.translated(\"advanced_feature_description\", #{});\n} else {\n    speak.text(\"This feature helps you automate tasks.\");\n}\n</code></pre>"},{"location":"modules/builtin/translation/#translationget_orkey-fallback","title":"<code>translation.get_or(key, fallback)</code>","text":"<p>Gets a translation or falls back to a default if not found.</p> <p>Parameters: - <code>key</code>: Translation key - <code>fallback</code>: Fallback text if key not found</p> <p>Returns: - <code>String</code>: Translated text or fallback</p> <pre><code>let message = translation.get_or(\"rare_error_code_5\", \"An unexpected error occurred.\");\n</code></pre>"},{"location":"modules/builtin/translation/#translationformat_with_placeholdersbase-context","title":"<code>translation.format_with_placeholders(base, context)</code>","text":"<p>Formats a string with placeholders from a context map.</p> <p>Parameters: - <code>base</code>: Text with placeholders in format {placeholder} - <code>context</code>: Map of placeholder values</p> <p>Returns: - <code>String</code>: Formatted text</p> <pre><code>let template = \"Hello, {name}! You have {count} new messages.\";\nlet formatted = translation.format_with_placeholders(template, #{ \n    \"name\": \"Taylor\", \n    \"count\": 5 \n});\n// Returns: \"Hello, Taylor! You have 5 new messages.\"\n</code></pre>"},{"location":"modules/builtin/translation/#translation-system","title":"Translation System","text":"<p>Translations are typically stored in language-specific files in the <code>responses</code> directory of your skill:</p> <pre><code>responses/\n\u251c\u2500\u2500 en/\n\u2502   \u2514\u2500\u2500 translations.json\n\u2514\u2500\u2500 es/\n    \u2514\u2500\u2500 translations.json\n</code></pre> <p>Example <code>translations.json</code> for English: <pre><code>{\n  \"welcome_user\": \"Welcome, {name}!\",\n  \"goodbye\": \"Goodbye, see you soon!\",\n  \"help_prompt\": \"What can I help you with today?\",\n  \"error_not_found\": \"Sorry, I couldn't find that information.\"\n}\n</code></pre></p>"},{"location":"modules/builtin/translation/#example-usage","title":"Example Usage","text":"<pre><code>on_start {\n    // Get current language\n    let current_lang = context.load(\"user_language\") or \"en\";\n\n    // Welcome message with name\n    let user_name = context.load(\"user_name\") or \"friend\";\n    let welcome = translation.get(\"welcome_user\", #{ \"name\": user_name });\n    speak.text(welcome);\n}\n\non_intent \"help_request\" {\n    let topic = intent.optional(\"topic\", \"\");\n\n    if topic != \"\" &amp;&amp; translation.exists(\"help_\" + topic) {\n        // Topic-specific help\n        speak.translated(\"help_\" + topic, #{});\n    } else {\n        // General help\n        speak.translated(\"help_general\", #{});\n\n        // List available topics\n        let help_topics = [\"accounts\", \"payments\", \"settings\"];\n        let topics_text = translation.get(\"available_help_topics\", #{ \n            \"topics\": help_topics.join(\", \") \n        });\n        speak.text(topics_text);\n    }\n}\n</code></pre>"},{"location":"modules/builtin/translation/#best-practices","title":"Best Practices","text":"<ol> <li>Use translation keys for all user-facing text</li> <li>Organize translations by feature or screen</li> <li>Use descriptive key names that indicate the purpose of the text</li> <li>Keep placeholders consistent across languages</li> <li>Provide fallbacks for missing translations</li> <li>Use raw translations when you need to perform custom formatting</li> <li>Consider cultural differences when designing translations</li> </ol>"},{"location":"operators/","title":"Operators","text":"<p>Arithmetic, logical, and conversion operators (e.g. assignment, type\u2010casting).</p>"},{"location":"operators/#contents","title":"Contents","text":"<p>Assignment Op Convert Num Op Operators</p>"},{"location":"operators/assignment-op/","title":"Compound Assignments","text":"<p>Compound assignments are assignments with a binary operator attached.</p> <pre><code>number += 8;            // number = number + 8\n\nnumber -= 7;            // number = number - 7\n\nnumber *= 6;            // number = number * 6\n\nnumber /= 5;            // number = number / 5\n\nnumber %= 4;            // number = number % 4\n\nnumber **= 3;           // number = number ** 3\n\nnumber &lt;&lt;= 2;           // number = number &lt;&lt; 2\n\nnumber &gt;&gt;= 1;           // number = number &gt;&gt; 1\n\nnumber &amp;= 0x00ff;       // number = number &amp; 0x00ff;\n\nnumber |= 0x00ff;       // number = number | 0x00ff;\n\nnumber ^= 0x00ff;       // number = number ^ 0x00ff;\n</code></pre>"},{"location":"operators/assignment-op/#the-flexible","title":"The Flexible <code>+=</code>","text":"<p>The the <code>+</code> and <code>+=</code> operators are often overloaded to perform build-up operations for different data types.</p>"},{"location":"operators/assignment-op/#build-strings","title":"Build strings","text":"<pre><code>let my_str = \"abc\";\n\nmy_str += \"ABC\";\nmy_str += 12345;\n\nmy_str == \"abcABC12345\"\n</code></pre>"},{"location":"operators/assignment-op/#concatenate-arrays","title":"Concatenate arrays","text":"<pre><code>let my_array = [1, 2, 3];\n\nmy_array += [4, 5];\n\nmy_array == [1, 2, 3, 4, 5];\n</code></pre>"},{"location":"operators/assignment-op/#concatenate-blobs","title":"Concatenate BLOB's","text":"<pre><code>let my_blob = blob(3, 0x42);\n\nmy_blob += blob(5, 0x89);\n\nmy_blob.to_string() == \"[4242428989898989]\";\n</code></pre>"},{"location":"operators/assignment-op/#mix-two-object-maps-together","title":"Mix two object maps together","text":"<pre><code>let my_obj = #{ a:1, b:2 };\n\nmy_obj += #{ c:3, d:4, e:5 };\n\nmy_obj == #{ a:1, b:2, c:3, d:4, e:5 };\n</code></pre>"},{"location":"operators/assignment-op/#add-seconds-to-timestamps","title":"Add seconds to timestamps","text":"<pre><code>let now = timestamp();\n\nnow += 42.0;\n\n(now - timestamp()).round() == 42.0;\n</code></pre>"},{"location":"operators/convert/","title":"Value Conversions","text":""},{"location":"operators/convert/#convert-between-integer-and-floating-point","title":"Convert Between Integer and Floating-Point","text":"Function From type To type <code>to_int</code> floating-point, decimal integer <code>to_float</code> integer, decimal floating-point <code>to_decimal</code> integer, floating-point decimal <p>That's it; for other conversions, register custom conversion functions.</p> <pre><code>let x = 42;                     // 'x' is an integer\n\nlet y = x * 100.0;              // integer and floating-point can inter-operate\n\nlet y = x.to_float() * 100.0;   // convert integer to floating-point with 'to_float'\n\nlet z = y.to_int() + x;         // convert floating-point to integer with 'to_int'\n\nlet d = y.to_decimal();         // convert floating-point to Decimal with 'to_decimal'\n\nlet w = z.to_decimal() + x;     // Decimal and integer can inter-operate\n\nlet c = 'X';                    // character\n\nprint(`c is '${c}' and its code is ${c.to_int()}`); // prints \"c is 'X' and its code is 88\"\n</code></pre>"},{"location":"operators/convert/#parse-string-into-number","title":"Parse String into Number","text":"Function From type To type <code>parse_int</code> string integer <code>parse_int</code> with radix 2-36 string integer (specified radix) <code>parse_float</code> string floating-point <code>parse_decimal</code> string decimal <pre><code>let x = parse_float(\"123.4\");   // parse as floating-point\nx == 123.4;\ntype_of(x) == \"f64\";\n\nlet x = parse_decimal(\"123.4\"); // parse as Decimal value\ntype_of(x) == \"decimal\";\n\nlet x = 1234.to_decimal() / 10; // alternate method to create a Decimal value\ntype_of(x) == \"decimal\";\n\nlet dec = parse_int(\"42\");      // parse as integer\ndec == 42;\ntype_of(dec) == \"i64\";\n\nlet dec = parse_int(\"42\", 10);  // radix = 10 is the default\ndec == 42;\ntype_of(dec) == \"i64\";\n\nlet bin = parse_int(\"110\", 2);  // parse as binary (radix = 2)\nbin == 0b110;\ntype_of(bin) == \"i64\";\n\nlet hex = parse_int(\"ab\", 16);  // parse as hex (radix = 16)\nhex == 0xab;\ntype_of(hex) == \"i64\";\n</code></pre>"},{"location":"operators/convert/#format-numbers","title":"Format Numbers","text":"Function From type To type Format <code>to_binary</code> integer string binary (i.e. only <code>1</code> and <code>0</code>) <code>to_octal</code> integer string octal (i.e. <code>0</code> ... <code>7</code>) <code>to_hex</code> integer string hex (i.e. <code>0</code> ... <code>f</code>) <pre><code>let x = 0x1234abcd;\n\nx == 305441741;\n\nx.to_string() == \"305441741\";\n\nx.to_binary() == \"10010001101001010101111001101\";\n\nx.to_octal() == \"2215125715\";\n\nx.to_hex() == \"1234abcd\";\n</code></pre>"},{"location":"operators/num-op/","title":"Numeric Operators","text":"<p>Numeric operators generally follow C styles.</p>"},{"location":"operators/num-op/#unary-operators","title":"Unary Operators","text":"Operator Description <code>+</code> positive <code>-</code> negative <pre><code>let number = +42;\n\nnumber = -5;\n\nnumber = -5 - +5;\n\n-(-42) == +42;      // two '-' equals '+'\n                    // beware: '++' and '--' are reserved symbols\n</code></pre>"},{"location":"operators/num-op/#binary-operators","title":"Binary Operators","text":"Operator Description Result type Integer Floating-point Decimal <code>+</code>, <code>+=</code> plus numeric yes yes, also integer yes, also integer <code>-</code>, <code>-=</code> minus numeric yes yes, also integer yes, also integer <code>*</code>, <code>*=</code> multiply numeric yes yes, also integer yes, also integer <code>/</code>, <code>/=</code> divide (integer division if acting on integer types) numeric yes yes, also integer yes, also integer <code>%</code>, <code>%=</code> modulo (remainder) numeric yes yes, also integer yes, also integer <code>**</code>, <code>**=</code> power/exponentiation numeric yes yes, also <code>FLOAT**INT</code> no <code>&lt;&lt;</code>, <code>&lt;&lt;=</code> left bit-shift (if negative number of bits, shift right instead) numeric yes no no <code>&gt;&gt;</code>, <code>&gt;&gt;=</code> right bit-shift (if negative number of bits, shift left instead) numeric yes no no <code>&amp;</code>, <code>&amp;=</code> bit-wise And numeric yes no no <code>|</code>, <code>|=</code> bit-wise Or numeric yes no no <code>^</code>, <code>^=</code> bit-wise Xor numeric yes no no <code>==</code> equals to <code>bool</code> yes yes, also integer yes, also integer <code>!=</code> not equals to <code>bool</code> yes yes, also integer yes, also integer <code>&gt;</code> greater than <code>bool</code> yes yes, also integer yes, also integer <code>&gt;=</code> greater than or equals to <code>bool</code> yes yes, also integer yes, also integer <code>&lt;</code> less than <code>bool</code> yes yes, also integer yes, also integer <code>&lt;=</code> less than or equals to <code>bool</code> yes yes, also integer yes, also integer <code>..</code> exclusive range range yes no no <code>..=</code> inclusive range range yes no no"},{"location":"operators/num-op/#examples","title":"Examples","text":"<pre><code>let x = (1 + 2) * (6 - 4) / 2;  // arithmetic, with parentheses\n\nlet reminder = 42 % 10;         // modulo\n\nlet power = 42 ** 2;            // power\n\nlet left_shifted = 42 &lt;&lt; 3;     // left shift\n\nlet right_shifted = 42 &gt;&gt; 3;    // right shift\n\nlet bit_op = 42 | 99;           // bit masking\n</code></pre>"},{"location":"operators/num-op/#floating-point-interoperates-with-integers","title":"Floating-Point Interoperates with Integers","text":"<p>When one of the operands to a binary arithmetic operator is floating-point, it works with integer for the other operand and the result is floating-point.</p> <pre><code>let x = 41.0 + 1;               // float + integer\n\ntype_of(x) == \"f64\";            // result is float\n\nlet x = 21 * 2.0;               // float * integer\n\ntype_of(x) == \"f64\";\n\n(x == 42) == true;              // float == integer\n\n(10 &lt; x) == true;               // integer &lt; float\n</code></pre>"},{"location":"operators/num-op/#decimal-interoperates-with-integers","title":"Decimal Interoperates with Integers","text":"<p>When one of the operands to a binary arithmetic operator is decimal, it works with integer for the other operand and the result is decimal.</p> <pre><code>let d = parse_decimal(\"2\");\n\nlet x = d + 1;                  // decimal + integer\n\ntype_of(x) == \"decimal\";        // result is decimal\n\nlet x = 21 * d;                 // decimal * integer\n\ntype_of(x) == \"decimal\";\n\n(x == 42) == true;              // decimal == integer\n\n(10 &lt; x) == true;               // integer &lt; decimal\n</code></pre>"},{"location":"operators/num-op/#unary-before-binary","title":"Unary Before Binary","text":"<p>In AviScript, unary operators take [precedence] over binary operators.  This is especially important to remember when handling operators such as <code>**</code> which in some languages bind tighter than the unary <code>-</code> operator.</p> <pre><code>-2 + 2 == 0;\n\n-2 - 2 == -4;\n\n-2 * 2 == -4;\n\n-2 / 2 == -1;\n\n-2 % 2 == 0;\n\n-2 ** 2 = 4;            // means: (-2) ** 2\n                        // in some languages this means: -(2 ** 2)\n</code></pre>"},{"location":"operators/operators/","title":"Comparison Operators","text":"Operator Description(<code>x</code> operator <code>y</code>) <code>x</code>, <code>y</code> same type or are numeric <code>x</code>, <code>y</code> different types <code>==</code> <code>x</code> is equals to <code>y</code> error if not defined <code>false</code> if not defined <code>!=</code> <code>x</code> is not equals to <code>y</code> error if not defined <code>true</code> if not defined <code>&gt;</code> <code>x</code> is greater than <code>y</code> error if not defined <code>false</code> if not defined <code>&gt;=</code> <code>x</code> is greater than or equals to <code>y</code> error if not defined <code>false</code> if not defined <code>&lt;</code> <code>x</code> is less than <code>y</code> error if not defined <code>false</code> if not defined <code>&lt;=</code> <code>x</code> is less than or equals to <code>y</code> error if not defined <code>false</code> if not defined <p>Comparison operators between most values of the same type are built in for all standard types.</p>"},{"location":"operators/operators/#floating-point-numbers-interoperate-with-integers","title":"Floating-point numbers interoperate with integers","text":"<p>Comparing a floating-point number with an integer is also supported.</p> <pre><code>42 == 42.0;         // true\n\n42.0 == 42;         // true\n\n42.0 &gt; 42;          // false\n\n42 &gt;= 42.0;         // true\n\n42.0 &lt; 42;          // false\n</code></pre>"},{"location":"operators/operators/#decimal-numbers-interoperate-with-integers","title":"Decimal numbers interoperate with integers","text":"<p>Comparing a decimal number with an integer is also supported.</p> <pre><code>let d = parse_decimal(\"42\");\n\n42 == d;            // true\n\nd == 42;            // true\n\nd &gt; 42;             // false\n\n42 &gt;= d;            // true\n\nd &lt; 42;             // false\n</code></pre>"},{"location":"operators/operators/#strings-interoperate-with-characters","title":"Strings interoperate with characters","text":"<p>Comparing a string with a character is also supported, with the character first turned into a string before performing the comparison.</p> <pre><code>'x' == \"x\";         // true\n\n\"\" &lt; 'a';           // true\n\n'x' &gt; \"hello\";      // false\n</code></pre>"},{"location":"operators/operators/#comparing-different-types-defaults-to-false","title":"Comparing different types defaults to <code>false</code>","text":"<p>Comparing two values of different data types defaults to <code>false</code> unless the appropriate operator functions have been registered.</p> <p>The exception is <code>!=</code> (not equals) which defaults to <code>true</code>. This is in line with intuition.</p> <pre><code>42 &gt; \"42\";          // false: i64 cannot be compared with string\n\n42 &lt;= \"42\";         // false: i64 cannot be compared with string\n\nlet ts = new_ts();  // custom type\n\nts == 42;           // false: different types cannot be compared\n\nts != 42;           // true: different types cannot be compared\n\nts == ts;           // error: '==' not defined for the custom type\n</code></pre>"},{"location":"operators/operators/#safety-valve-comparing-different-numeric-types-has-no-default","title":"Safety valve: Comparing different numeric types has no default","text":"<p>Beware that the above default does NOT apply to numeric values of different types (e.g. comparison between <code>i64</code> and <code>u16</code>, <code>i32</code> and <code>f64</code>) \u2013 when multiple numeric types are used it is too easy to mess up and for subtle errors to creep in.</p> <pre><code>// Assume variable 'x' = 42_u16, 'y' = 42_u16 (both types of u16)\n\nx == y;             // true: '==' operator for u16 is built-in\n\nx == \"hello\";       // false: different non-numeric operand types default to false\n\nx == 42;            // error: ==(u16, i64) not defined, no default for numeric types\n\n42 == y;            // error: ==(i64, u16) not defined, no default for numeric types\n</code></pre>"},{"location":"operators/operators/#boolean-operators","title":"Boolean Operators","text":"<p>```admonish note.side</p> <p>All boolean operators are built in for the <code>bool</code> data type. <pre><code>|     Operator      | Description | Arity  | Short-circuits? |\n| :---------------: | :---------: | :----: | :-------------: |\n|  `!` _(prefix)_   |    _NOT_    | unary  |       no        |\n|       `&amp;&amp;`        |    _AND_    | binary |     **yes**     |\n|        `&amp;`        |    _AND_    | binary |       no        |\n| &lt;code&gt;\\|\\|&lt;/code&gt; |    _OR_     | binary |     **yes**     |\n|  &lt;code&gt;\\|&lt;/code&gt;  |    _OR_     | binary |       no        |\n\nDouble boolean operators `&amp;&amp;` and `||` _short-circuit_ &amp;ndash; meaning that the second operand will not be evaluated\nif the first one already proves the condition wrong.\n\nSingle boolean operators `&amp;` and `|` always evaluate both operands.\n\n```rust\na() || b();         // b() is not evaluated if a() is true\n\na() &amp;&amp; b();         // b() is not evaluated if a() is false\n\na() | b();          // both a() and b() are evaluated\n\na() &amp; b();          // both a() and b() are evaluated\n</code></pre></p>"},{"location":"operators/operators/#null-coalescing-operator","title":"Null-Coalescing Operator","text":"Operator Description Arity Short-circuits? <code>??</code> Null-coalesce binary yes <p>The null-coalescing operator (<code>??</code>) returns the first operand if it is not <code>()</code>, or the second operand if the first operand is <code>()</code>.</p> <p>This operator short-circuits  \u2013 meaning that the second operand will not be evaluated if the first operand is not <code>()</code>.</p> <pre><code>a ?? b              // returns 'a' if it is not (), otherwise 'b'\n\na() ?? b();         // b() is only evaluated if a() is ()\n</code></pre> <p>~~~admonish tip.small \"Tip: Default value for object map property\"</p> <p>Use the null-coalescing operator to implement default values for non-existent object map properties.</p> <p><pre><code>let map = #{ foo: 42 };\n\n// Regular property access\nlet x = map.foo;            // x == 42\n\n// Non-existent property\nlet x = map.bar;            // x == ()\n\n// Default value for property\nlet x = map.bar ?? 42;      // x == 42\n</code></pre> ~~~</p>"},{"location":"operators/operators/#short-circuit-loops-and-early-returns","title":"Short-circuit loops and early returns","text":"<p>The following statements are allowed to follow the null-coalescing operator:</p> <ul> <li><code>break</code></li> <li><code>continue</code></li> <li><code>return</code></li> <li><code>throw</code></li> </ul> <p>This means that you can use the null-coalescing operator to short-circuit loops and/or early-return from functions when the value tested is <code>()</code>.</p> <p>```rust let total = 0;</p> <p>for value in list {     // Whenever 'calculate' returns '()', the loop stops     total += calculate(value) ?? break; } ```</p>"},{"location":"operators/operators/#in-operator","title":"In Operator","text":"<p>```admonish question.side \"Trivia\"</p> <p>The <code>in</code> operator is simply syntactic sugar for a call to the <code>contains</code> function.</p> <p>Similarly, <code>!in</code> is a call to <code>!contains</code>. ```</p> <p>The <code>in</code> operator is used to check for containment \u2013 i.e. whether a particular collection data type contains a particular item.</p> <p>Similarly, <code>!in</code> is used to check for non-existence \u2013 i.e. it is <code>true</code> if a particular collection data type does not contain a particular item.</p> <p>```rust 42 in array;</p> <p>array.contains(42);     // &lt;- the above is equivalent to this</p> <p>123 !in array;</p> <p>!array.contains(123);   // &lt;- the above is equivalent to this ```</p>"},{"location":"operators/operators/#built-in-support-for-standard-data-types","title":"Built-in support for standard data types","text":"Data type Check for Numeric range integer number array contained item Object map property name string sub-string or character"},{"location":"operators/operators/#examples","title":"Examples","text":"<p>```rust let array = [1, \"abc\", 42, ()];</p> <p>42 in array == true;                // check array for item</p> <p>let map = #{     foo: 42,     bar: true,     baz: \"hello\" };</p> <p>\"foo\" in map == true;               // check object map for property name</p> <p>'w' in \"hello, world!\" == true;     // check string for character</p> <p>'w' !in \"hello, world!\" == false;</p> <p>\"wor\" in \"hello, world\" == true;    // check string for sub-string</p> <p>42 in -100..100 == true;            // check range for number ```</p>"},{"location":"operators/operators/#or-operator","title":"<code>or</code> Operator","text":"<p>The <code>or</code> operator provides a way to use a default value when a string is empty.</p>"},{"location":"operators/operators/#syntax","title":"Syntax","text":"<p><code>expression1 or expression2</code></p>"},{"location":"operators/operators/#behavior","title":"Behavior","text":"<p>If <code>expression1</code> evaluates to a non-empty string, it's returned. Otherwise, <code>expression2</code> is returned.</p>"},{"location":"operators/operators/#example","title":"Example","text":"<p>``` let user_input = \"\"; let name = user_input or \"Anonymous\";  // name will be \"Anonymous\"</p> <p>let greeting = \"Hello\"; let message = greeting or \"Hi\";  // message will be \"Hello\" ```</p>"},{"location":"statements/","title":"Statements","text":"<p>One\u2010off statements and dynamic tags, evaluation, and error handling.</p>"},{"location":"statements/#contents","title":"Contents","text":"<p>Eval Statements</p>"},{"location":"statements/eval/","title":"<code>eval</code> Function","text":""},{"location":"statements/eval/#or-how-to-shoot-yourself-in-the-foot-even-easier","title":"Or \"How to Shoot Yourself in the Foot even Easier\"","text":"<p>Saving the best for last, there is the ever-dreaded... <code>eval</code> function!</p> <pre><code>let x = 10;\n\nfn foo(x) { x += 12; x }\n\nlet script =\n\"\n    let y = x;\n    y += foo(y);\n    x + y\n\";\n\nlet result = eval(script);      // &lt;- look, JavaScript, we can also do this!\n\nresult == 42;\n\nx == 10;                        // prints 10 - arguments are passed by value\ny == 32;                        // prints 32 - variables defined in 'eval' persist!\n\neval(\"{ let z = y }\");          // to keep a variable local, use a statements block\n\nprint(z);                       // &lt;- error: variable 'z' not found\n\n\"print(42)\".eval();             // &lt;- nope... method-call style doesn't work with 'eval'\n</code></pre> <p>~~~admonish danger.small \"<code>eval</code> executes inside the current scope!\"</p> <p>Script segments passed to <code>eval</code> execute inside the current scope, so they can access and modify everything, including all variables that are visible at that position in code!</p> <pre><code>let script = \"x += 32\";\n\nlet x = 10;\neval(script);       // variable 'x' is visible!\nprint(x);           // prints 42\n\n// The above is equivalent to:\nlet script = \"x += 32\";\nlet x = 10;\nx += 32;\nprint(x);\n</code></pre> <p><code>eval</code> can also be used to define new variables and do other things normally forbidden inside a function call.</p> <pre><code>let script = \"let x = 42\";\neval(script);\nprint(x);           // prints 42\n</code></pre> <p>Treat it as if the script segments are physically pasted in at the position of the <code>eval</code> call. <pre><code>~~~admonish warning.small \"Cannot define new functions\"\n\nNew [functions](functions/functions.md) cannot be defined within an `eval` call, since [functions](functions/functions.md)\ncan only be defined at the _global_ level!\n</code></pre></p>"},{"location":"statements/statements/","title":"Statements","text":"<p>Statements are terminated by semicolons <code>;</code> and they are mandatory, except for the last statement in a block (enclosed by <code>{</code> ... <code>}</code> pairs) where it can be omitted.</p> <p>Semicolons can also be omitted for statement types that always end in a block \u2013 for example the <code>if</code>, <code>while</code>, <code>for</code>,  <code>loop</code> and <code>switch</code>statements.</p> <pre><code>let a = 42;             // normal assignment statement\nlet a = foo(42);        // normal function call statement\nfoo &lt; 42;               // normal expression as statement\n\nlet a = { 40 + 2 };     // 'a' is set to the value of the statements block, which is the value of the last statement\n//              ^ the last statement does not require a terminating semicolon (but also works with it)\n//                ^ semicolon required here to terminate the 'let' statement\n//                  it is a syntax error without it, even though it ends with '}'\n//                  that is because the 'let' statement doesn't end in a block\n\nif foo { a = 42 }\n//               ^ no need to terminate an if-statement with a semicolon\n//                 that is because the 'if' statement ends in a block\n\n4 * 10 + 2              // a statement which is just one expression - no ending semicolon is OK\n                        // because it is the last statement of the whole block\n</code></pre>"},{"location":"statements/statements/#statements-block","title":"Statements Block","text":""},{"location":"statements/statements/#syntax","title":"Syntax","text":"<p>Statements blocks in AviScript are formed by enclosing zero or more statements within braces <code>{</code>...<code>}</code>.</p> <p><code>{</code> statement<code>;</code> statement<code>;</code> ... statement <code>}</code></p> <p><code>{</code> statement<code>;</code> statement<code>;</code> ... statement<code>;</code> <code>}</code> <code>// trailing semi-colon is optional</code></p>"},{"location":"statements/statements/#closed-scope","title":"Closed scope","text":"<p>A statements block forms a closed scope.</p> <p>Any variable and/or constant defined within the block are removed outside the block, so are modules imported within the block.</p> <pre><code>let x = 42;\nlet y = 18;\n\n{\n    import \"hello\" as h;\n    const HELLO = 99;\n    let y = 0;\n\n    h::greet();         // ok\n\n    print(y + HELLO);   // prints 99 (y is zero)\n\n        :    \n        :    \n}                       // &lt;- 'HELLO' and 'y' go away here...\n\nprint(x + y);           // prints 60 (y is still 18)\n\nprint(HELLO);           // &lt;- error: 'HELLO' not found\n\nh::greet();             // &lt;- error: module 'h' not found\n</code></pre>"},{"location":"statements/statements/#statement-expression","title":"Statement Expression","text":"<p>A statement can be used anywhere where an expression is expected.</p> <p>These are called, for lack of a more creative name, \"statement expressions.\"</p> <p>The last statement of a statements block is always the block's return value when used as a statement, regardless of whether it is terminated by a semicolon or not.</p> <p>If the last statement has no return value (e.g. variable definitions, assignments) then it is assumed to be <code>()</code>.</p> <pre><code>let x = {\n    let foo = calc_something();\n    let bar = foo + baz;\n    bar.further_processing();       // &lt;- this is the return value\n};                                  // &lt;- semicolon is needed here...\n\n// The above is equivalent to:\nlet result;\n{\n    let foo = calc_something();\n    let bar = foo + baz;\n    result = bar.further_processing();\n}\nlet x = result;\n\n// Statement expressions can be inserted inside normal expressions\n// to avoid duplicated calculations\nlet x = foo(bar) + { let v = calc(); process(v, v.len, v.abs) } + baz;\n\n// The above is equivalent to:\nlet foo_result = foo(bar);\nlet calc_result;\n{\n    let v = calc();\n    result = process(v, v.len, v.abs);  // &lt;- avoid calculating 'v'\n}\nlet x = foo_result + calc_result + baz;\n\n// Statement expressions are also useful as function call arguments\n// when side effects are desired\ndo_work(x, y, { let z = foo(x, y); print(z); z });\n           // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n           //       statement expression\n</code></pre>"},{"location":"types/","title":"Types","text":"<p>Built\u2011in data types: numbers, strings, arrays, maps, blobs, bit\u2011fields, constants.</p>"},{"location":"types/#contents","title":"Contents","text":"<p>Arrays Bit Fields Blobs Fn Ptr Numbers Object Maps Strings Chars Timestamps Values And Types Dynamic Oop</p>"},{"location":"types/arrays/","title":"Arrays","text":"<p>Arrays are first-class citizens in AviScript.</p> <p>All elements stored in an array are dynamic, and the array can freely grow or shrink with elements added or removed.</p> <p><code>type_of()</code> an array returns <code>\"array\"</code>.</p>"},{"location":"types/arrays/#literal-syntax","title":"Literal Syntax","text":"<p>Array literals are built within square brackets <code>[</code> ... <code>]</code> and separated by commas <code>,</code>:</p> <p><code>[</code> value<code>,</code> value<code>,</code> ... <code>,</code> value <code>]</code></p> <p><code>[</code> value<code>,</code> value<code>,</code> ... <code>,</code> value <code>,</code> <code>]</code> <code>// trailing comma is OK</code></p>"},{"location":"types/arrays/#element-access-syntax","title":"Element Access Syntax","text":""},{"location":"types/arrays/#from-beginning","title":"From beginning","text":"<p>Like C, arrays are accessed with zero-based, non-negative integer indices:</p> <p>array <code>[</code> index position from 0 to length\u22121 <code>]</code></p>"},{"location":"types/arrays/#from-end","title":"From end","text":"<p>A negative position accesses an element in the array counting from the end, with \u22121 being the last element.</p> <p>array <code>[</code> index position from \u22121 to \u2212length <code>]</code></p>"},{"location":"types/arrays/#built-in-functions","title":"Built-in Functions","text":"<p>The following methods operate on arrays.</p> Function Parameter(s) Description <code>get</code> position, counting from end if &lt; 0 gets a copy of the element at a certain position (<code>()</code> if the position is not valid) <code>set</code> <ol><li>position, counting from end if &lt; 0</li><li>new element</li></ol> sets a certain position to a new value (no effect if the position is not valid) <code>push</code>, <code>+=</code> operator element to append (not an array) appends an element to the end <code>append</code>, <code>+=</code> operator array to append concatenates the second array to the end of the first <code>+</code> operator <ol><li>first array</li><li>second array</li></ol> concatenates the first array with the second <code>==</code> operator <ol><li>first array</li><li>second array</li></ol> are two arrays the same (elements compared with the <code>==</code> operator, if defined)? <code>!=</code> operator <ol><li>first array</li><li>second array</li></ol> are two arrays different (elements compared with the <code>==</code> operator, if defined)? <code>insert</code> <ol><li>position, counting from end if &lt; 0, end if \u2265 length</li><li>element to insert</li></ol> inserts an element at a certain position <code>pop</code> none removes the last element and returns it (<code>()</code> if empty) <code>shift</code> none removes the first element and returns it (<code>()</code> if empty) <code>extract</code> <ol><li>start position, counting from end if &lt; 0, end if \u2265 length</li><li>(optional) number of elements to extract, none if \u2264 0, to end if omitted</li></ol> extracts a portion of the array into a new array <code>extract</code> range of elements to extract, from beginning if \u2264 0, to end if \u2265 length extracts a portion of the array into a new array <code>remove</code> position, counting from end if &lt; 0 removes an element at a particular position and returns it (<code>()</code> if the position is not valid) <code>reverse</code> none reverses the array <code>len</code> method and property none returns the number of elements <code>is_empty</code> method and property none returns <code>true</code> if the array is empty <code>pad</code> <ol><li>target length</li><li>element to pad</li></ol> pads the array with an element to at least a specified length <code>clear</code> none empties the array <code>truncate</code> target length cuts off the array at exactly a specified length (discarding all subsequent elements) <code>chop</code> target length cuts off the head of the array, leaving the tail at exactly a specified length <code>split</code> <ol><li>array</li><li>position to split at, counting from end if &lt; 0, end if \u2265 length</li></ol> splits the array into two arrays, starting from a specified position <code>for_each</code> function pointer for processing elements run through each element in the array in order, binding each to <code>this</code> and calling the processing function taking the following parameters: <ol><li><code>this</code>: array element</li><li>(optional) index position</li></ol> <code>drain</code> function pointer to predicate (usually a closure) removes all elements (returning them) that return <code>true</code> when called with the predicate function taking the following parameters (if none, the array element is bound to <code>this</code>):<ol><li>array element</li><li>(optional) index position</li></ol> <code>drain</code> <ol><li>start position, counting from end if &lt; 0, end if \u2265 length</li><li>number of elements to remove, none if \u2264 0</li></ol> removes a portion of the array, returning the removed elements as a new array <code>drain</code> range of elements to remove, from beginning if \u2264 0, to end if \u2265 length removes a portion of the array, returning the removed elements as a new array <code>retain</code> function pointer to predicate (usually a closure) removes all elements (returning them) that do not return <code>true</code> when called with the predicate function taking the following parameters (if none, the array element is bound to <code>this</code>):<ol><li>array element</li><li>(optional) index position</li></ol> <code>retain</code> <ol><li>start position, counting from end if &lt; 0, end if \u2265 length</li><li>number of elements to retain, none if \u2264 0</li></ol> retains a portion of the array, removes all other elements and returning them as a new array <code>retain</code> range of elements to retain, from beginning if \u2264 0, to end if \u2265 length retains a portion of the array, removes all other bytes and returning them as a new array <code>splice</code> <ol><li>start position, counting from end if &lt; 0, end if \u2265 length</li><li>number of elements to remove, none if \u2264 0</li><li>array to insert</li></ol> replaces a portion of the array with another (not necessarily of the same length as the replaced portion) <code>splice</code> <ol><li>range of elements to remove, from beginning if \u2264 0, to end if \u2265 length</li><li>array to insert</li></ol> replaces a portion of the array with another (not necessarily of the same length as the replaced portion) <code>filter</code> function pointer to predicate (usually a closure) constructs a new array with all elements that return <code>true</code> when called with the predicate function taking the following parameters (if none, the array element is bound to <code>this</code>):<ol><li>array element</li><li>(optional) index position</li></ol> <code>contains</code>, <code>in</code> operator element to find does the array contain an element? The <code>==</code> operator is used for comparison <code>index_of</code> <ol><li>element to find (not a function pointer)</li><li>(optional) start position, counting from end if &lt; 0, end if \u2265 length</li></ol> returns the position of the first element in the array that equals the supplied element (using the <code>==</code> operator, if defined), or \u22121 if not found <code>index_of</code> <ol><li>function pointer to predicate (usually a closure)</li><li>(optional) start position, counting from end if &lt; 0, end if \u2265 length</li></ol> returns the position of the first element in the array that returns <code>true</code> when called with the predicate function, or \u22121 if not found:<ol><li><code>this</code>: array element</li><li>(optional) index position</li></ol> <code>find</code> <ol><li>function pointer to predicate (usually a closure)</li><li>(optional) start position, counting from end if &lt; 0, end if \u2265 length</li></ol> returns the first element in the array that returns <code>true</code> when called with the predicate function, or <code>()</code> if not found:<ol><li>array element (if none, the array element is bound to <code>this</code>)</li><li>(optional) index position</li></ol> <code>find_map</code> <ol><li>function pointer to predicate (usually a closure)</li><li>(optional) start position, counting from end if &lt; 0, end if \u2265 length</li></ol> returns the first non-<code>()</code> value of the first element in the array when called with the predicate function, or <code>()</code> if not found:<ol><li>array element (if none, the array element is bound to <code>this</code>)</li><li>(optional) index position</li></ol> <code>dedup</code> (optional) function pointer to predicate (usually a closure); if omitted, the <code>==</code> operator is used, if defined removes all but the first of consecutive elements in the array that return <code>true</code> when called with the predicate function (non-consecutive duplicates are not removed):1st &amp; 2nd parameters: two elements in the array <code>map</code> function pointer to conversion function (usually a closure) constructs a new array with all elements mapped to the result of applying the conversion function taking the following parameters (if none, the array element is bound to <code>this</code>):<ol><li>array element</li><li>(optional) index position</li></ol> <code>reduce</code> <ol><li>function pointer to accumulator function (usually a closure)</li><li>(optional) the initial value</li></ol> reduces the array into a single value via the accumulator function taking the following parameters (if the second parameter is omitted, the array element is bound to <code>this</code>):<ol><li>accumulated value (<code>()</code> initially)</li><li>array element</li><li>(optional) index position</li></ol> <code>reduce_rev</code> <ol><li>function pointer to accumulator function (usually a closure)</li><li>(optional) the initial value</li></ol> reduces the array (in reverse order) into a single value via the accumulator function taking the following parameters (if the second parameter is omitted, the array element is bound to <code>this</code>):<ol><li>accumulated value (<code>()</code> initially)</li><li>array element</li><li>(optional) index position</li></ol> <code>some</code> function pointer to predicate (usually a closure) returns <code>true</code> if any element returns <code>true</code> when called with the predicate function taking the following parameters (if none, the array element is bound to <code>this</code>):<ol><li>array element</li><li>(optional) index position</li></ol> <code>all</code> function pointer to predicate (usually a closure) returns <code>true</code> if all elements return <code>true</code> when called with the predicate function taking the following parameters (if none, the array element is bound to <code>this</code>):<ol><li>array element</li><li>(optional) index position</li></ol> <code>sort</code> function pointer to a comparison function (usually a closure) sorts the array with a comparison function taking the following parameters:<ol><li>first element</li><li>second elementreturn value: <code>INT</code> &lt; 0 if first &lt; second, &gt; 0 if first &gt; second, 0 if first == second</li></ol> <code>sort</code> none sorts a homogeneous array containing only elements of the same comparable built-in type (integers, floating-point, decimal, string, character, <code>bool</code>, <code>()</code>)"},{"location":"types/arrays/#examples","title":"Examples","text":"<pre><code>let y = [2, 3];             // y == [2, 3]\n\nlet y = [2, 3,];            // y == [2, 3]\n\ny.insert(0, 1);             // y == [1, 2, 3]\n\ny.insert(999, 4);           // y == [1, 2, 3, 4]\n\ny.len == 4;\n\ny[0] == 1;\ny[1] == 2;\ny[2] == 3;\ny[3] == 4;\n\n(1 in y) == true;           // use 'in' to test if an element exists in the array\n\n(42 in y) == false;         // 'in' uses the 'contains' function, which uses the\n                            // '==' operator (that users can override)\n                            // to check if the target element exists in the array\n\ny.contains(1) == true;      // the above de-sugars to this\n\ny[1] = 42;                  // y == [1, 42, 3, 4]\n\n(42 in y) == true;\n\ny.remove(2) == 3;           // y == [1, 42, 4]\n\ny.len == 3;\n\ny[2] == 4;                  // elements after the removed element are shifted\n\nts.list = y;                // arrays can be assigned completely (by value copy)\n\nts.list[1] == 42;\n\n[1, 2, 3][0] == 1;          // indexing on array literal\n\n[1, 2, 3][-1] == 3;         // negative position counts from the end\n\nfn abc() {\n    [42, 43, 44]            // a function returning an array\n}\n\nabc()[0] == 42;\n\ny.push(4);                  // y == [1, 42, 4, 4]\n\ny += 5;                     // y == [1, 42, 4, 4, 5]\n\ny.len == 5;\n\ny.shift() == 1;             // y == [42, 4, 4, 5]\n\ny.chop(3);                  // y == [4, 4, 5]\n\ny.len == 3;\n\ny.pop() == 5;               // y == [4, 4]\n\ny.len == 2;\n\nfor element in y {          // arrays can be iterated with a 'for' statement\n    print(element);\n}\n\ny.pad(6, \"hello\");          // y == [4, 4, \"hello\", \"hello\", \"hello\", \"hello\"]\n\ny.len == 6;\n\ny.truncate(4);              // y == [4, 4, \"hello\", \"hello\"]\n\ny.len == 4;\n\ny.clear();                  // y == []\n\ny.len == 0;\n\n// The examples below use 'a' as the master array\n\nlet a = [42, 123, 99];\n\na.map(|v| v + 1);           // returns [43, 124, 100]\n\na.map(|| this + 1);         // returns [43, 124, 100]\n\na.map(|v, i| v + i);        // returns [42, 124, 101]\n\na.filter(|v| v &gt; 50);       // returns [123, 99]\n\na.filter(|| this &gt; 50);     // returns [123, 99]\n\na.filter(|v, i| i == 1);    // returns [123]\n\na.filter(\"is_odd\");         // returns [123, 99]\n\na.filter(Fn(\"is_odd\"));     // &lt;- previous statement is equivalent to this...\n\na.filter(|v| is_odd(v));    // &lt;- or this\n\na.some(|v| v &gt; 50);         // returns true\n\na.some(|| this &gt; 50);       // returns true\n\na.some(|v, i| v &lt; i);       // returns false\n\na.all(|v| v &gt; 50);          // returns false\n\na.all(|| this &gt; 50);        // returns false\n\na.all(|v, i| v &gt; i);        // returns true\n\n// Reducing - initial value provided directly\na.reduce(|sum| sum + this, 0) == 264;\n\n// Reducing - initial value provided directly\na.reduce(|sum, v| sum + v, 0) == 264;\n\n// Reducing - initial value is '()'\na.reduce(\n    |sum, v| if sum.type_of() == \"()\" { v } else { sum + v }\n) == 264;\n\n// Reducing - initial value has index position == 0\na.reduce(|sum, v, i|\n    if i == 0 { v } else { sum + v }\n) == 264;\n\n// Reducing in reverse - initial value provided directly\na.reduce_rev(|sum| sum + this, 0) == 264;\n\n// Reducing in reverse - initial value provided directly\na.reduce_rev(|sum, v| sum + v, 0) == 264;\n\n// Reducing in reverse - initial value is '()'\na.reduce_rev(\n    |sum, v| if sum.type_of() == \"()\" { v } else { sum + v }\n) == 264;\n\n// Reducing in reverse - initial value has index position == 0\na.reduce_rev(|sum, v, i|\n    if i == 2 { v } else { sum + v }\n) == 264;\n\n// In-place modification\n\na.splice(1..=1, [1, 3, 2]); // a == [42, 1, 3, 2, 99]\n\na.extract(1..=3);           // returns [1, 3, 2]\n\na.sort(|x, y| y - x);       // a == [99, 42, 3, 2, 1]\n\na.sort();                   // a == [1, 2, 3, 42, 99]\n\na.drain(|v| v &lt;= 1);        // a == [2, 3, 42, 99]\n\na.drain(|v, i| i \u2265 3);      // a == [2, 3, 42]\n\na.retain(|v| v &gt; 10);       // a == [42]\n\na.retain(|v, i| i &gt; 0);     // a == []\n</code></pre>"},{"location":"types/bit-fields/","title":"Integer as Bit-Fields","text":"<p>```admonish note.side</p> <p>Nothing here cannot be done via standard bit-manipulation (i.e. shifting and masking).</p> <p>Built-in support is more elegant and performant since it usually replaces a sequence of multiple steps.</p> <pre><code>Since bit-wise operators are defined on integer numbers, individual bits can also be accessed and\nmanipulated via an indexing syntax.\n\nIf a bit is set (i.e. `1`), the index access returns `true`.\n\nIf a bit is not set (i.e. `0`), the index access returns `false`.\n\nWhen a [range](variables/ranges.md) is used, the bits within the [range](variables/ranges.md) are shifted and extracted\nas an integer value.\n\nBit-fields are very commonly used in embedded systems which must squeeze data into limited memory.\n\nBuilt-in support makes handling them efficient.\n\n\nSyntax\n------\n\n### From Least-Significant Bit (LSB)\n\nBits in a bit-field are accessed with zero-based, non-negative integer indices:\n\n&gt; _integer_ `[` _index from 0 to 63 or 31_ `]`\n&gt;\n&gt; _integer_ `[` _index from 0 to 63 or 31_ `] =` `true` or `false` ;\n\n[Ranges] can also be used:\n\n&gt; _integer_ `[` _start_ `..` _end_ `]`  \n&gt; _integer_ `[` _start_ `..=` _end_ `]`\n&gt;\n&gt; _integer_ `[` _start_ `..` _end_ `] =` _new integer value_ ;  \n&gt; _integer_ `[` _start_ `..=` _end_ `] =` _new integer value_ ;\n\n```admonish warning.small \"Number of bits\"\n\nThe maximum bit number that can be accessed is one less than the number of bits for the\nsystem integer type (usually 63).\n\nBits outside of the range are ignored.\n</code></pre>"},{"location":"types/bit-fields/#from-most-significant-bit-msb","title":"From Most-Significant Bit (MSB)","text":"<p>A negative index accesses a bit in the bit-field counting from the end, or from the most-significant bit, with \u22121 being the highest bit.</p> <p>integer <code>[</code> index from \u22121 to \u221264 or \u221232 <code>]</code></p> <p>integer <code>[</code> index from \u22121 to \u221264 or \u221232 <code>] =</code> <code>true</code> or <code>false</code> ;</p> <p>ranges always count from the least-significant bit (LSB) and has no support for negative positions.</p> <p>```admonish warning.small \"Number of bits\"</p> <p>The maximum bit number that can be accessed is negative the number of bits for the system integer type (usually \u221264). <pre><code>Bit-Field Functions\n-------------------\n\nThe following standard functions operate on bit-fields.\n\n| Function                   | Parameter(s)                                                                                                                                                   | Description                                               |\n| -------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------- |\n| `get_bit`                  | bit number, counting from MSB if &lt; 0                                                                                                                           | returns the state of a bit: `true` if `1`, `false` if `0` |\n| `set_bit`                  | &lt;ol&gt;&lt;li&gt;bit number, counting from MSB if &lt; 0&lt;/li&gt;&lt;li&gt;new state: `true` if `1`, `false` if `0`&lt;/li&gt;&lt;/ol&gt;                                                        | sets the state of a bit                                   |\n| `get_bits`                 | &lt;ol&gt;&lt;li&gt;starting bit number, counting from MSB if &lt; 0&lt;/li&gt;&lt;li&gt;number of bits to extract, none if &lt; 1, to MSB if \u2265 _length_&lt;/li&gt;&lt;/ol&gt;                           | extracts a number of bits, shifted towards LSB            |\n| `get_bits`                 | [range](variables/ranges.md) of bits                                                                                                                                     | extracts a number of bits, shifted towards LSB            |\n| `set_bits`                 | &lt;ol&gt;&lt;li&gt;starting bit number, counting from MSB if &lt; 0&lt;/li&gt;&lt;li&gt;number of bits to set, none if &lt; 1, to MSB if \u2265 _length_&lt;br/&gt;3) new value&lt;/li&gt;&lt;/ol&gt;              | sets a number of bits from the new value                  |\n| `set_bits`                 | &lt;ol&gt;&lt;li&gt;[range](variables/ranges.md) of bits&lt;/li&gt;&lt;li&gt;new value&lt;/li&gt;&lt;/ol&gt;                                                                                                 | sets a number of bits from the new value                  |\n| `bits` method and property | &lt;ol&gt;&lt;li&gt;_(optional)_ starting bit number, counting from MSB if &lt; 0&lt;/li&gt;&lt;li&gt;_(optional)_ number of bits to extract, none if &lt; 1, to MSB if \u2265 _length_&lt;/li&gt;&lt;/ol&gt; | allows iteration over the bits of a bit-field             |\n| `bits`                     | [range](variables/ranges.md) of bits                                                                                                                                     | allows iteration over the bits of a bit-field             |\n\n\nExample\n-------\n\n```js , no_run\n// Assume the following bits fields in a single 16-bit word:\n// \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n// \u2502  15-12  \u2502    11-4    \u2502  3   \u2502   2-0   \u2502\n// \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n// \u2502    0    \u2502 0-255 data \u2502 flag \u2502 command \u2502\n// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nlet value = read_start_hw_register(42);\n\nlet command = value.get_bits(0, 3);         // Command = bits 0-2\n\nlet flag = value[3];                        // Flag = bit 3\n\nlet data = value[4..=11];                   // Data = bits 4-11\nlet data = value.get_bits(4..=11);          // &lt;- above is the same as this\n\nlet reserved = value.get_bits(-4);          // Reserved = last 4 bits\n\nif reserved != 0 {\n    throw reserved;\n}\n\nswitch command {\n    0 =&gt; print(`Data = ${data}`),\n    1 =&gt; value[4..=11] = data / 2,\n    2 =&gt; value[3] = !flag,\n    _ =&gt; print(`Unknown: ${command}`)\n}\n</code></pre></p>"},{"location":"types/blobs/","title":"BLOB's","text":"<p>BLOB's (Binary Large OBjects), used to hold packed arrays of bytes, have built-in support in AviScript.</p> <p>A BLOB has no literal representation, but is created via the <code>blob</code> function, or simply returned as the result of a function call (e.g. <code>generate_thumbnail_image</code> that generates a thumbnail version of a large image as a BLOB).</p> <p>All items stored in a BLOB are bytes (i.e. <code>u8</code>) and the BLOB can freely grow or shrink with bytes added or removed.</p> <p><code>type_of()</code> a BLOB returns <code>\"blob\"</code>.</p>"},{"location":"types/blobs/#element-access-syntax","title":"Element Access Syntax","text":""},{"location":"types/blobs/#from-beginning","title":"From beginning","text":"<p>Like arrays, BLOB's are accessed with zero-based, non-negative integer indices:</p> <p>blob <code>[</code> index position from 0 to length\u22121 <code>]</code></p>"},{"location":"types/blobs/#from-end","title":"From end","text":"<p>A negative position accesses an element in the BLOB counting from the end, with \u22121 being the last element.</p> <p>blob <code>[</code> index position from \u22121 to \u2212length <code>]</code></p> <p>```admonish info.small \"Byte values\"</p> <p>The value of a particular byte in a BLOB is mapped to an integer.</p> <p>Only the lowest 8 bits are significant, all other bits are ignored. <pre><code>Create a BLOB\n-------------\n\nThe function `blob` allows creating an empty BLOB, optionally filling it to a required size with a\nparticular value (default zero).\n\n```rust\nlet x = blob();             // empty BLOB\n\nlet x = blob(10);           // BLOB with ten zeros\n\nlet x = blob(50, 42);       // BLOB with 50x 42's\n</code></pre></p> <p>```admonish tip \"Tip: Initialize with byte stream\"</p> <p>To quickly initialize a BLOB with a particular byte stream, the <code>write_be</code> method can be used to write eight bytes at a time (four under 32-bit) in big-endian byte order.</p> <p>If fewer than eight bytes are needed, remember to right-pad the number as big-endian byte order is used.</p> <p><pre><code>let buf = blob(12, 0);      // BLOB with 12x zeros\n\n// Write eight bytes at a time, in big-endian order\nbuf.write_be(0, 8, 0xab_cd_ef_12_34_56_78_90);\nbuf.write_be(8, 8, 0x0a_0b_0c_0d_00_00_00_00);\n                            //   ^^^^^^^^^^^ remember to pad unused bytes\n\nprint(buf);                 // prints \"[abcdef1234567890 0a0b0c0d]\"\n\nbuf[3] == 0x12;\nbuf[10] == 0x0c;\n\n// Under 'only_i32', write four bytes at a time:\nbuf.write_be(0, 4, 0xab_cd_ef_12);\nbuf.write_be(4, 4, 0x34_56_78_90);\nbuf.write_be(8, 4, 0x0a_0b_0c_0d);\n</code></pre> <pre><code>Writing ASCII Bytes\n-------------------\n\n```admonish warning.side \"Non-ASCII\"\n\nNon-ASCII characters (i.e. characters not within 1-127) are ignored.\n</code></pre></p> <p>For many embedded applications, it is necessary to encode an ASCII string as a byte stream.</p> <p>Use the <code>write_ascii</code> method to write ASCII strings into any specific range within a BLOB.</p> <p>The following is an example of a building a 16-byte command to send to an embedded device.</p> <pre><code>// Assume the following 16-byte command for an embedded device:\n// \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n// \u2502    0    \u2502       1       \u2502              2-13                \u2502 14-15 \u2502\n// \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n// \u2502 command \u2502 string length \u2502 ASCII string, max. 12 characters \u2502  CRC  \u2502\n// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nlet buf = blob(16, 0);      // initialize command buffer\n\nlet text = \"foo &amp; bar\";     // text string to send to device\n\nbuf[0] = 0x42;              // command code\nbuf[1] = s.len();           // length of string\n\nbuf.write_ascii(2..14, text);   // write the string\n\nlet crc = buf.calc_crc();   // calculate CRC\n\nbuf.write_le(14, 2, crc);   // write CRC\n\nprint(buf);                 // prints \"[4209666f6f202620 626172000000abcd]\"\n                            //          ^^ command code              ^^^^ CRC\n                            //            ^^ string length\n                            //              ^^^^^^^^^^^^^^^^^^^ foo &amp; bar\n\ndevice.send(buf);           // send command to device\n</code></pre> <p>```admonish question.small \"What if I need UTF-8?\"</p> <p>The <code>write_utf8</code> function writes a string in UTF-8 encoding.</p> <p>UTF-8, however, is not very common for embedded applications. ```</p>"},{"location":"types/blobs/#built-in-functions","title":"Built-in Functions","text":"<p>The following functions operate on BLOB's.</p> Functions Parameter(s) Description <code>blob</code> constructor function <ol><li>(optional) initial length of the BLOB</li><li>(optional) initial byte value</li></ol> creates a new BLOB, optionally of a particular length filled with an initial byte value (default = 0) <code>to_array</code> none converts the BLOB into an array of integers <code>as_string</code> none converts the BLOB into a string (the byte stream is interpreted as UTF-8) <code>get</code> position, counting from end if &lt; 0 gets a copy of the byte at a certain position (0 if the position is not valid) <code>set</code> <ol><li>position, counting from end if &lt; 0</li><li>new byte value</li></ol> sets a certain position to a new value (no effect if the position is not valid) <code>push</code>, <code>append</code>, <code>+=</code> operator <ol><li>BLOB</li><li>byte to append</li></ol> appends a byte to the end <code>append</code>, <code>+=</code> operator <ol><li>BLOB</li><li>BLOB to append</li></ol> concatenates the second BLOB to the end of the first <code>append</code>, <code>+=</code> operator <ol><li>BLOB</li><li>string/character to append</li></ol> concatenates a string/character (as UTF-8 encoded byte-stream) to the end of the BLOB <code>+</code> operator <ol><li>first BLOB</li><li>string to append</li></ol> creates a new string by concatenating the BLOB (as UTF-8 encoded byte-stream) with the the string <code>+</code> operator <ol><li>string</li><li>BLOB to append</li></ol> creates a new string by concatenating the BLOB (as UTF-8 encoded byte-stream) to the end of the string <code>+</code> operator <ol><li>first BLOB</li><li>second BLOB</li></ol> concatenates the first BLOB with the second <code>==</code> operator <ol><li>first BLOB</li><li>second BLOB</li></ol> are two BLOB's the same? <code>!=</code> operator <ol><li>first BLOB</li><li>second BLOB</li></ol> are two BLOB's different? <code>insert</code> <ol><li>position, counting from end if &lt; 0, end if \u2265 length</li><li>byte to insert</li></ol> inserts a byte at a certain position <code>pop</code> none removes the last byte and returns it (0 if empty) <code>shift</code> none removes the first byte and returns it (0 if empty) <code>extract</code> <ol><li>start position, counting from end if &lt; 0, end if \u2265 length</li><li>(optional) number of bytes to extract, none if \u2264 0</li></ol> extracts a portion of the BLOB into a new BLOB <code>extract</code> range of bytes to extract, from beginning if \u2264 0, to end if \u2265 length extracts a portion of the BLOB into a new BLOB <code>remove</code> position, counting from end if &lt; 0 removes a byte at a particular position and returns it (0 if the position is not valid) <code>reverse</code> none reverses the BLOB byte by byte <code>len</code> method and property none returns the number of bytes in the BLOB <code>is_empty</code> method and property none returns <code>true</code> if the BLOB is empty <code>pad</code> <ol><li>target length</li><li>byte value to pad</li></ol> pads the BLOB with a byte value to at least a specified length <code>clear</code> none empties the BLOB <code>truncate</code> target length cuts off the BLOB at exactly a specified length (discarding all subsequent bytes) <code>chop</code> target length cuts off the head of the BLOB, leaving the tail at exactly a specified length <code>contains</code>, <code>in</code> operator byte value to find does the BLOB contain a particular byte value? <code>split</code> <ol><li>BLOB</li><li>position to split at, counting from end if &lt; 0, end if \u2265 length</li></ol> splits the BLOB into two BLOB's, starting from a specified position <code>drain</code> <ol><li>start position, counting from end if &lt; 0, end if \u2265 length</li><li>number of bytes to remove, none if \u2264 0</li></ol> removes a portion of the BLOB, returning the removed bytes as a new BLOB <code>drain</code> range of bytes to remove, from beginning if \u2264 0, to end if \u2265 length removes a portion of the BLOB, returning the removed bytes as a new BLOB <code>retain</code> <ol><li>start position, counting from end if &lt; 0, end if \u2265 length</li><li>number of bytes to retain, none if \u2264 0</li></ol> retains a portion of the BLOB, removes all other bytes and returning them as a new BLOB <code>retain</code> range of bytes to retain, from beginning if \u2264 0, to end if \u2265 length retains a portion of the BLOB, removes all other bytes and returning them as a new BLOB <code>splice</code> <ol><li>start position, counting from end if &lt; 0, end if \u2265 length</li><li>number of bytes to remove, none if \u2264 0</li><li>BLOB to insert</li></ol> replaces a portion of the BLOB with another (not necessarily of the same length as the replaced portion) <code>splice</code> <ol><li>range of bytes to remove, from beginning if \u2264 0, to end if \u2265 length</li><li>BLOB to insert replaces a portion of the BLOB with another (not necessarily of the same length as the replaced portion) <code>parse_le_int</code> <ol><li>start position, counting from end if &lt; 0, end if \u2265 length</li><li>number of bytes to parse, 8 if &gt; 8 (4 under 32-bit), none if \u2264 0</li></ol> parses an integer at the particular offset in little-endian byte order (if not enough bytes, zeros are padded; extra bytes are ignored) <code>parse_le_int</code> range of bytes to parse, from beginning if \u2264 0, to end if \u2265 length (up to 8 bytes, 4 under 32-bit) parses an integer at the particular offset in little-endian byte order (if not enough bytes, zeros are padded; extra bytes are ignored) <code>parse_be_int</code> <ol><li>start position, counting from end if &lt; 0, end if \u2265 length</li><li>number of bytes to parse, 8 if &gt; 8 (4 under 32-bit), none if \u2264 0</li></ol> parses an integer at the particular offset in big-endian byte order (if not enough bytes, zeros are padded; extra bytes are ignored) <code>parse_be_int</code> range of bytes to parse, from beginning if \u2264 0, to end if \u2265 length (up to 8 bytes, 4 under 32-bit) parses an integer at the particular offset in big-endian byte order (if not enough bytes, zeros are padded; extra bytes are ignored) <code>parse_le_float</code> <ol><li>start position, counting from end if &lt; 0, end if \u2265 length</li><li>number of bytes to parse, 8 if &gt; 8 (4 under 32-bit), none if \u2264 0</li></ol> parses a floating-point number at the particular offset in little-endian byte order (if not enough bytes, zeros are padded; extra bytes are ignored) <code>parse_le_float</code> range of bytes to parse, from beginning if \u2264 0, to end if \u2265 length (up to 8 bytes, 4 under 32-bit) parses a floating-point number at the particular offset in little-endian byte order (if not enough bytes, zeros are padded; extra bytes are ignored) <code>parse_be_float</code> <ol><li>start position, counting from end if &lt; 0, end if \u2265 length</li><li>number of bytes to parse, 8 if &gt; 8 (4 under 32-bit), none if \u2264 0</li></ol> parses a floating-point number at the particular offset in big-endian byte order (if not enough bytes, zeros are padded; extra bytes are ignored) <code>parse_be_float</code> range of bytes to parse, from beginning if \u2264 0, to end if \u2265 length (up to 8 bytes, 4 under 32-bit) parses a floating-point number at the particular offset in big-endian byte order (if not enough bytes, zeros are padded; extra bytes are ignored) <code>write_le</code> <ol><li>start position, counting from end if &lt; 0, end if \u2265 length</li><li>number of bytes to write, 8 if &gt; 8 (4 under 32-bit), none if \u2264 0</li><li>integer or floating-point value</li></ol> writes a value at the particular offset in little-endian byte order (if not enough bytes, zeros are padded; extra bytes are ignored) <code>write_le</code> <ol><li>range of bytes to write, from beginning if \u2264 0, to end if \u2265 length (up to 8 bytes, 4 under 32-bit)</li><li>integer or floating-point value</li></ol> writes a value at the particular offset in little-endian byte order (if not enough bytes, zeros are padded; extra bytes are ignored) <code>write_be</code> <ol><li>start position, counting from end if &lt; 0, end if \u2265 length</li><li>number of bytes to write, 8 if &gt; 8 (4 under 32-bit), none if \u2264 0</li><li>integer or floating-point value</li></ol> writes a value at the particular offset in big-endian byte order (if not enough bytes, zeros are padded; extra bytes are ignored) <code>write_be</code> <ol><li>range of bytes to write, from beginning if \u2264 0, to end if \u2265 length (up to 8 bytes, 4 under 32-bit)</li><li>integer or floating-point value</li></ol> writes a value at the particular offset in big-endian byte order (if not enough bytes, zeros are padded; extra bytes are ignored) <code>write_utf8</code> <ol><li>start position, counting from end if &lt; 0, end if \u2265 length</li><li>number of bytes to write, none if \u2264 0, to end if \u2265 length</li><li>string to write</li></ol> writes a string to the particular offset in UTF-8 encoding <code>write_utf8</code> <ol><li>range of bytes to write, from beginning if \u2264 0, to end if \u2265 length, to end if \u2265 length</li><li>string to write</li></ol> writes a string to the particular offset in UTF-8 encoding <code>write_ascii</code> <ol><li>start position, counting from end if &lt; 0, end if \u2265 length</li><li>number of characters to write, none if \u2264 0, to end if \u2265 length</li><li>string to write</li></ol> writes a string to the particular offset in 7-bit ASCII encoding (non-ASCII characters are skipped) <code>write_ascii</code> <ol><li>range of bytes to write, from beginning if \u2264 0, to end if \u2265 length, to end if \u2265 length</li><li>string to write</li></ol> writes a string to the particular offset in 7-bit ASCII encoding (non-ASCII characters are skipped)"},{"location":"types/fn-ptr/","title":"Function Pointers","text":"<p>It is possible to store a function pointer in a variable just like a normal value.</p> <p>A function pointer is created via the <code>Fn</code> function, which takes a string parameter.</p> <p>Call a function pointer via the <code>call</code> method.</p>"},{"location":"types/fn-ptr/#short-hand-notation","title":"Short-Hand Notation","text":"<p>```admonish warning.side \"Not for native\"</p> <p>Native Rust functions cannot use this short-hand notation. <pre><code>Having to write `Fn(\"foo\")` in order to create a function pointer to the [function](../functions/functions.md)\n`foo` is a chore, so there is a short-hand available.\n\nA function pointer to any _script-defined_ [function](../functions/functions.md) _within the same script_ can be\nobtained simply by referring to the [function's](../functions/functions.md) name.\n\n```rust\nfn foo() { ... }        // function definition\n\nlet f = foo;            // function pointer to 'foo'\n\nlet f = Fn(\"foo\");      // &lt;- the above is equivalent to this\n\nlet g = bar;            // error: variable 'bar' not found\n</code></pre></p> <p>The short-hand notation is particularly useful when passing functions as closure arguments.</p> <pre><code>fn is_even(n) { n % 2 == 0 }\n\nlet array = [1, 2, 3, 4, 5];\n\narray.filter(is_even);\n\narray.filter(Fn(\"is_even\"));    // &lt;- the above is equivalent to this\n\narray.filter(|n| n % 2 == 0);   // &lt;- ... or this\n</code></pre>"},{"location":"types/fn-ptr/#built-in-functions","title":"Built-in Functions","text":"<p>The following standard methods operate on function pointers.</p> Function Parameter(s) Description <code>name</code> method and property none returns the name of the function encapsulated by the function pointer <code>is_anonymous</code> method and property none does the function pointer refer to an anonymous function? <code>call</code> arguments calls the function matching the function pointer's name with the arguments"},{"location":"types/fn-ptr/#examples","title":"Examples","text":"<pre><code>fn foo(x) { 41 + x }\n\nlet func = Fn(\"foo\");       // use the 'Fn' function to create a function pointer\n\nlet func = foo;             // &lt;- short-hand: equivalent to 'Fn(\"foo\")'\n\nprint(func);                // prints 'Fn(foo)'\n\nlet func = fn_name.Fn();    // &lt;- error: 'Fn' cannot be called in method-call style\n\nfunc.type_of() == \"Fn\";     // type_of() as function pointer is 'Fn'\n\nfunc.name == \"foo\";\n\nfunc.call(1) == 42;         // call a function pointer with the 'call' method\n\nfoo(1) == 42;               // &lt;- the above de-sugars to this\n\ncall(func, 1);              // normal function call style also works for 'call'\n\nlet len = Fn(\"len\");        // 'Fn' also works with registered native Rust functions\n\nlen.call(\"hello\") == 5;\n\nlet fn_name = \"hello\";      // the function name does not have to exist yet\n\nlet hello = Fn(fn_name + \"_world\");\n\nhello.call(0);              // error: function not found - 'hello_world (i64)'\n</code></pre> <p>```admonish warning \"Not First-Class Functions\"</p> <p>Beware that function pointers are not first-class functions.</p> <p>They are syntactic sugar only, capturing only the name of a function to call. They do not hold the actual functions.</p> <p>The actual function must be defined in the appropriate namespace for the call to succeed. <pre><code>~~~admonish warning \"Global Namespace Only\"\n\nBecause of their dynamic nature, function pointers cannot refer to functions in\n[`import`](modules/import.md)-ed [modules](modules/index.md).\n\nThey can only refer to [functions](functions/functions.md) defined globally within the script\nor a built-in function.\n\n```js\nimport \"foo\" as f;          // assume there is 'f::do_work()'\n\nf::do_work();               // works!\n\nlet p = Fn(\"f::do_work\");   // error: invalid function name\n\nfn do_work_now() {          // call it from a local function\n    f::do_work();\n}\n\nlet p = Fn(\"do_work_now\");\n\np.call();                   // works!\n</code></pre> ~~~</p>"},{"location":"types/fn-ptr/#dynamic-dispatch","title":"Dynamic Dispatch","text":"<p>The purpose of function pointers is to enable rudimentary dynamic dispatch, meaning to determine, at runtime, which function to call among a group.</p> <p>Although it is possible to simulate dynamic dispatch via a number and a large <code>if-then-else-if</code> statement, using function pointers significantly simplifies the code.</p> <p>```rust let x = some_calculation();</p> <p>// These are the functions to call depending on the value of 'x' fn method1(x) { ... } fn method2(x) { ... } fn method3(x) { ... }</p> <p>// Traditional - using decision variable let func = sign(x);</p> <p>// Dispatch with if-statement if func == -1 {     method1(42); } else if func == 0 {     method2(42); } else if func == 1 {     method3(42); }</p> <p>// Using pure function pointer let func = if x &lt; 0 {     method1 } else if x == 0 {     method2 } else if x &gt; 0 {     method3 };</p> <p>// Dynamic dispatch func.call(42);</p> <p>// Using functions map let map = [ method1, method2, method3 ];</p> <p>let func = sign(x) + 1;</p> <p>// Dynamic dispatch map[func].call(42); ```</p>"},{"location":"types/fn-ptr/#bind-the-this-pointer","title":"Bind the <code>this</code> Pointer","text":"<p>When <code>call</code> is called as a method but not on a function pointer, it is possible to dynamically dispatch to a function call while binding the object in the method call to the <code>this</code> pointer of the function.</p> <p>To achieve this, pass the function pointer as the first argument to <code>call</code>:</p> <p>```rust fn add(x) {                 // define function which uses 'this'     this += x; }</p> <p>let func = add;             // function pointer to 'add'</p> <p>func.call(1);               // error: 'this' pointer is not bound</p> <p>let x = 41;</p> <p>func.call(x, 1);            // error: function 'add (i64, i64)' not found</p> <p>call(func, x, 1);           // error: function 'add (i64, i64)' not found</p> <p>x.call(func, 1);            // 'this' is bound to 'x', dispatched to 'func'</p> <p>x == 42; ```</p> <p>Beware that this only works for method-call style. Normal function-call style cannot bind the <code>this</code> pointer (for syntactic reasons).</p>"},{"location":"types/fn-ptr/#currying","title":"Currying","text":"<p>It is possible to curry a function pointer by providing partial (or all) arguments.</p> <p>Currying is done via the <code>curry</code> keyword and produces a new function pointer which carries the curried arguments.</p> <p>When the curried function pointer is called, the curried arguments are inserted starting from the left.</p> <p>The actual call arguments should be reduced by the number of curried arguments.</p> <p>```rust fn mul(x, y) {                  // function with two parameters     x * y }</p> <p>let func = mul;                 // &lt;- de-sugars to 'Fn(\"mul\")'</p> <p>func.call(21, 2) == 42;         // two arguments are required for 'mul'</p> <p>let curried = func.curry(21);   // currying produces a new function pointer which                                 // carries 21 as the first argument</p> <p>let curried = curry(func, 21);  // function-call style also works</p> <p>curried.call(2) == 42;          // &lt;- de-sugars to 'func.call(21, 2)'                                 //    only one argument is now required ```</p>"},{"location":"types/numbers/","title":"Numbers","text":""},{"location":"types/numbers/#integers","title":"Integers","text":"<p>Integer numbers follow C-style format with support for decimal, binary (<code>0b</code>), octal (<code>0o</code>) and hex (<code>0x</code>) notations.</p> <p>Integers can also be conveniently manipulated as bit-fields.</p>"},{"location":"types/numbers/#floating-point-numbers","title":"Floating-Point Numbers","text":"<p>Both decimal and scientific notations can be used to represent floating-point numbers.</p>"},{"location":"types/numbers/#decimal-numbers","title":"Decimal Numbers","text":"<p>When rounding errors cannot be accepted, such as in financial calculations, use the decimal type, which is a fixed-precision floating-point number with no rounding errors.</p>"},{"location":"types/numbers/#number-literals","title":"Number Literals","text":"<p><code>_</code> separators can be added freely and are ignored within a number \u2013 except at the very beginning or right after a decimal point (<code>.</code>).</p> Sample Format <code>_123</code> improper separator <code>123_345</code>, <code>-42</code> decimal <code>0o07_76</code> octal <code>0xab_cd_ef</code> hex <code>0b0101_1001</code> binary <code>123._456</code> improper separator <code>123_456.78_9</code> normal floating-point <code>-42.</code> ending with decimal point <code>123_456_.789e-10</code> scientific notation <code>.456</code> missing leading <code>0</code> <code>123.456e_10</code> improper separator <code>123.e-10</code> missing decimal <code>0</code>"},{"location":"types/numbers/#floating-point-vs-decimal","title":"Floating-Point vs. Decimal","text":"<p>Decimal numbers represents a fixed-precision floating-point number which is popular with financial calculations and other usage scenarios where round-off errors are not acceptable.</p> <p>Decimal numbers take up more space (16 bytes each) than a standard floating-point number (4-8 bytes) and is much slower in calculations due to the lack of CPU hardware support. Use it only when necessary.</p>"},{"location":"types/object-maps/","title":"Object Maps","text":"<p>Object maps are hash dictionaries. Properties are all dynamic values and can be freely added and retrieved.</p> <p><code>type_of()</code> an object map returns <code>\"map\"</code>.</p> <p>~~~admonish tip \"Tip: Object maps are FAST\"</p> <p>Normally, when properties are accessed, copies of the data values are made. This is normally slow.</p> <p>Object maps have special treatment \u2013 properties are accessed via references, meaning that no copies of data values are made.</p> <p>This makes object map access fast, especially when deep within a properties chain.</p> <p><pre><code>// 'obj' is a normal custom type\nlet x = obj.a.b.c.d;\n\n// The above is equivalent to:\nlet a_value = obj.a;        // temp copy of 'a'\nlet b_value = a_value.b;    // temp copy of 'b'\nlet c_value = b_value.c;    // temp copy of 'c'\nlet d_value = c_value.d;    // temp copy of 'd'\nlet x = d_value;\n\n// 'map' is an object map\nlet x = map.a.b.c.d;        // direct access to 'd'\n                            // 'a', 'b' and 'c' are not copied\n\nmap.a.b.c.d = 42;           // directly modifies 'd' in 'a', 'b' and 'c'\n                            // no copy of any property value is made\n\nmap.a.b.c.d.calc();         // directly calls 'calc' on 'd'\n                            // no copy of any property value is made\n</code></pre> ~~~</p>"},{"location":"types/object-maps/#literal-syntax","title":"Literal Syntax","text":"<p>Object map literals are built within braces <code>#{</code> ... <code>}</code> with name<code>:</code>value pairs separated by commas <code>,</code>:</p> <p><code>#{</code> property <code>:</code> value<code>,</code> ... <code>,</code> property <code>:</code> value <code>}</code></p> <p><code>#{</code> property <code>:</code> value<code>,</code> ... <code>,</code> property <code>:</code> value <code>,</code> <code>}</code> <code>// trailing comma is OK</code></p> <p>The property name can be a simple identifier following the same naming rules as variables, or a string literal without interpolation.</p>"},{"location":"types/object-maps/#property-access-syntax","title":"Property Access Syntax","text":""},{"location":"types/object-maps/#dot-notation","title":"Dot notation","text":"<p>The dot notation allows only property names that follow the same naming rules as variables.</p> <p>object <code>.</code> property</p>"},{"location":"types/object-maps/#elvis-notation","title":"Elvis notation","text":"<p>The Elvis notation is similar to the dot notation except that it returns <code>()</code> if the object itself is <code>()</code>.</p> <p><code>// returns () if object is ()</code> object <code>?.</code> property</p> <p><code>// no action if object is ()</code> object <code>?.</code> property <code>=</code> value <code>;</code></p>"},{"location":"types/object-maps/#index-notation","title":"Index notation","text":"<p>The index notation allows setting/getting properties of arbitrary names (even the empty string).</p> <p>object <code>[</code> property <code>]</code></p>"},{"location":"types/object-maps/#handle-non-existent-properties","title":"Handle Non-Existent Properties","text":"<p>Trying to read a non-existent property returns <code>()</code> instead of causing an error.</p> <p>This is similar to JavaScript where accessing a non-existent property returns <code>undefined</code>.</p> <p>```rust let map = #{ foo: 42 };</p> <p>// Regular property access let x = map.foo;            // x == 42</p> <p>// Non-existent property let x = map.bar;            // x == () ```</p>"},{"location":"types/object-maps/#check-for-property-existence","title":"Check for property existence","text":"<p>Use the <code>in</code> operator to check whether a property exists in an object-map.</p> <p>```rust let map = #{ foo: 42 };</p> <p>\"foo\" in map == true;</p> <p>\"bar\" in map == false; ```</p>"},{"location":"types/object-maps/#short-circuit-non-existent-property-access","title":"Short-circuit non-existent property access","text":"<p>Use the Elvis operator (<code>?.</code>) to short-circuit further processing if the object is <code>()</code>.</p> <p>```rust x.a.b.foo();        // &lt;- error if 'x', 'x.a' or 'x.a.b' is ()</p> <p>x.a.b = 42;         // &lt;- error if 'x' or 'x.a' is ()</p> <p>x?.a?.b?.foo();     // &lt;- ok! returns () if 'x', 'x.a' or 'x.a.b' is ()</p> <p>x?.a?.b = 42;       // &lt;- ok even if 'x' or 'x.a' is () ```</p>"},{"location":"types/object-maps/#default-property-value","title":"Default property value","text":"<p>Using the null-coalescing operator to give non-existent properties default values.</p> <p>```rust let map = #{ foo: 42 };</p> <p>// Regular property access let x = map.foo;            // x == 42</p> <p>// Non-existent property let x = map.bar;            // x == ()</p> <p>// Default value for property let x = map.bar ?? 42;      // x == 42 ```</p>"},{"location":"types/object-maps/#built-in-functions","title":"Built-in Functions","text":"<p>The following methods operate on object maps.</p> Function Parameter(s) Description <code>get</code> property name gets a copy of the value of a certain property (<code>()</code> if the property does not exist) <code>set</code> <ol><li>property name</li><li>new element</li></ol> sets a certain property to a new value (property is added if not already exists) <code>len</code> none returns the number of properties <code>is_empty</code> none returns <code>true</code> if the object map is empty <code>clear</code> none empties the object map <code>remove</code> property name removes a certain property and returns it (<code>()</code> if the property does not exist) <code>+=</code> operator, <code>mixin</code> second object map mixes in all the properties of the second object map to the first (values of properties with the same names replace the existing values) <code>+</code> operator <ol><li>first object map</li><li>second object map</li></ol> merges the first object map with the second <code>==</code> operator <ol><li>first object map</li><li>second object map</li></ol> are the two object maps the same (elements compared with the <code>==</code> operator, if defined)? <code>!=</code> operator <ol><li>first object map</li><li>second object map</li></ol> are the two object maps different (elements compared with the <code>==</code> operator, if defined)? <code>fill_with</code> second object map adds in all properties of the second object map that do not exist in the object map <code>contains</code>, <code>in</code> operator property name does the object map contain a property of a particular name? <code>drain</code> function pointer to predicate (usually a closure) removes all elements (returning them) that return <code>true</code> when called with the predicate function taking the following parameters:<ol><li>key</li><li>(optional) object map element (if omitted, the object map element is bound to <code>this</code>)</li></ol> <code>retain</code> function pointer to predicate (usually a closure) removes all elements (returning them) that do not return <code>true</code> when called with the predicate function taking the following parameters:<ol><li>key</li><li>(optional) object map element (if omitted, the object map element is bound to <code>this</code>)</li></ol> <code>filter</code> function pointer to predicate (usually a closure) constructs a object map with all elements that return <code>true</code> when called with the predicate function taking the following parameters:<ol><li>key</li><li>(optional) object map element (if omitted, the object map element is bound to <code>this</code>)</li></ol> <code>keys</code> none returns an array of all the property names (in random order) <code>values</code> none returns an array of all the property values (in random order) <code>to_json</code> none returns a JSON representation of the object map (<code>()</code> is mapped to <code>null</code>, all other data types must be supported by JSON)"},{"location":"types/object-maps/#examples","title":"Examples","text":"<p>```rust let y = #{              // object map literal with 3 properties     a: 1,     bar: \"hello\",     \"baz!$@\": 123.456,  // like JavaScript, you can use any string as property names...     \"\": false,          // even the empty string!</p> <pre><code>`hello`: 999,       // literal strings are also OK\n\na: 42,              // &lt;- syntax error: duplicated property name\n\n`a${2}`: 42,        // &lt;- syntax error: property name cannot have string interpolation\n</code></pre> <p>};</p> <p>y.a = 42;               // access via dot notation y.a == 42;</p> <p>y.baz!$@ = 42;          // &lt;- syntax error: only proper variable names allowed in dot notation y.\"baz!$@\" = 42;        // &lt;- syntax error: strings not allowed in dot notation y[\"baz!$@\"] = 42;       // access via index notation is OK</p> <p>\"baz!$@\" in y == true;  // use 'in' to test if a property exists in the object map (\"z\" in y) == false;</p> <p>ts.obj = y;             // object maps can be assigned completely (by value copy) let foo = ts.list.a; foo == 42;</p> <p>let foo = #{ a:1, };    // trailing comma is OK</p> <p>let foo = #{ a:1, b:2, c:3 }[\"a\"]; let foo = #{ a:1, b:2, c:3 }.a; foo == 1;</p> <p>fn abc() {     #{ a:1, b:2, c:3 }  // a function returning an object map }</p> <p>let foo = abc().b; foo == 2;</p> <p>let foo = y[\"a\"]; foo == 42;</p> <p>y.contains(\"a\") == true; y.contains(\"xyz\") == false;</p> <p>y.xyz == ();            // a non-existent property returns '()' y[\"xyz\"] == ();</p> <p>y.len == ();            // an object map has no property getter function y.len() == 3;           // method calls are OK</p> <p>y.remove(\"a\") == 1;     // remove property</p> <p>y.len() == 2; y.contains(\"a\") == false;</p> <p>for name in y.keys() {  // get an array of all the property names via 'keys'     print(name); }</p> <p>for val in y.values() { // get an array of all the property values via 'values'     print(val); }</p> <p>y.clear();              // empty the object map</p> <p>y.len() == 0; ```</p>"},{"location":"types/object-maps/#special-support-for-oop","title":"Special Support for OOP","text":"<p>Object maps can be used to simulate object-oriented programming (OOP) by storing data as properties and methods as properties holding function pointers.</p> <p>If an object map's property holds a function pointer, the property can simply be called like a normal method in method-call syntax.</p> <p>This is a short-hand to avoid the more verbose syntax of using the <code>call</code> function keyword.</p> <p>When a property holding a function pointer or a closure is called like a method, it is replaced as a method call on the object map itself.</p> <p>```rust let obj = #{                 data: 40,                 action: || this.data += x    // 'action' holds a closure            };</p> <p>obj.action(2);                               // calls the function pointer with 'this' bound to 'obj'</p> <p>obj.call(obj.action, 2);                     // &lt;- the above de-sugars to this</p> <p>obj.data == 42;</p> <p>// To achieve the above with normal function pointer call will fail.</p> <p>fn do_action(map, x) { map.data += x; }      // 'map' is a copy</p> <p>obj.action = do_action;                      // &lt;- de-sugars to 'Fn(\"do_action\")'</p> <p>obj.action.call(obj, 2);                     // a copy of 'obj' is passed by value</p> <p>obj.data == 42;                              // 'obj.data' is not changed ```</p>"},{"location":"types/strings-chars/","title":"Strings and Characters","text":"<p>String in AviScript contain any text sequence of valid Unicode characters.</p> <p><code>type_of()</code> a string returns <code>\"string\"</code>.</p>"},{"location":"types/strings-chars/#string-and-character-literals","title":"String and Character Literals","text":"<p>String and character literals follow JavaScript-style syntax.</p> Type Quotes Escapes? Continuation? Interpolation? Normal string <code>\"...\"</code> yes with <code>\\</code> no Raw string <code>#..#\"...\"#..#</code> no no no Multi-line literal string <code>`...`</code> no no with <code>${...}</code> Character <code>'...'</code> yes no no <p>```admonish tip.small \"Tip: Building strings\"</p> <p>Strings can be built up from other strings and types via the <code>+</code> or <code>+=</code> operators. <pre><code>Standard Escape Sequences\n-------------------------\n\n~~~admonish tip.side \"Tip: Character `to_int()`\"\n\nUse the `to_int` method to convert a Unicode character into its 32-bit Unicode encoding.\n~~~\n\nThere is built-in support for Unicode (`\\u`_xxxx_ or `\\U`_xxxxxxxx_) and hex (`\\x`_xx_) escape\nsequences for normal strings and characters.\n\nHex sequences map to ASCII characters, while `\\u` maps to 16-bit common Unicode code points and `\\U`\nmaps the full, 32-bit extended Unicode code points.\n\nEscape sequences are not supported for multi-line literal strings wrapped by back-ticks (`` ` ``).\n\n| Escape sequence | Meaning                          |\n| --------------- | -------------------------------- |\n| `\\\\`            | back-slash (`\\`)                 |\n| `\\t`            | tab                              |\n| `\\r`            | carriage-return (`CR`)           |\n| `\\n`            | line-feed (`LF`)                 |\n| `\\\"` or `\"\"`    | double-quote (`\"`)               |\n| `\\'`            | single-quote (`'`)               |\n| `\\x`_xx_        | ASCII character in 2-digit hex   |\n| `\\u`_xxxx_      | Unicode character in 4-digit hex |\n| `\\U`_xxxxxxxx_  | Unicode character in 8-digit hex |\n\n\nLine Continuation\n-----------------\n\nFor a normal string wrapped by double-quotes (`\"`), a back-slash (`\\`) character at the end of a\nline indicates that the string continues onto the next line _without any line-break_.\n\nWhitespace up to the indentation of the opening double-quote is ignored in order to enable lining up\nblocks of text.\n\nSpaces are _not_ added, so to separate one line with the next with a space, put a space before the\nending back-slash (`\\`) character.\n\n```rust\nlet x = \"hello, world!\\\n         hello world again! \\\n         this is the \"\"last\"\" time!!!\";\n// ^^^^^^ these whitespaces are ignored\n\n// The above is the same as:\nlet x = \"hello, world!hello world again! this is the \\\"last\\\" time!!!\";\n</code></pre></p> <p>A string with continuation does not open up a new line.  To do so, a new-line character must be manually inserted at the appropriate position.</p> <pre><code>let x = \"hello, world!\\n\\\n         hello world again!\\n\\\n         this is the last time!!!\";\n\n// The above is the same as:\nlet x = \"hello, world!\\nhello world again!\\nthis is the last time!!!\";\n</code></pre> <p>~~~admonish warning.small \"No ending quote before the line ends is a syntax error\"</p> <p>If the ending double-quote is omitted, it is a syntax error.</p> <p><pre><code>let x = \"hello\n# \";\n//            ^ syntax error: unterminated string literal\n</code></pre> <pre><code>```admonish question.small \"Why not go multi-line?\"\n\nTechnically speaking, there is no difficulty in allowing strings to run for multiple lines\n_without_ the continuation back-slash.\n\nAviScript forces you to manually mark a continuation with a back-slash because the ending quote is easy to omit.\nOnce it happens, the entire remainder of the script would become one giant, multi-line string.\n\nThis behavior is different from Rust, where string literals can run for multiple lines.\n```\n\n\nRaw Strings\n-----------\n\nA _raw string_ is any text enclosed by a pair of double-quotes (`\"`), wrapped by hash (`#`) characters.\n\nThe number of hash (`#`) on each side must be the same.\n\nAny text inside the double-quotes, as long as it is not a double-quote (`\"`) followed by the same\nnumber of hash (`#`) characters, is simply copied verbatim, _including control codes and/or\nline-breaks_.\n\nRaw strings are very useful for embedded regular expressions, file paths, and program code etc.\n\n```rust\nlet x = #\"Hello, I am a raw string! which means that I can contain\n             line-breaks, \\ slashes (not escapes), \"quotes\" and even # characters!\"#\n\n// Use more than one '#' if you happen to have '\"###...' inside the string...\n\nlet x = ###\"In AviScript, you can write ##\"hello\"## as a raw string.\"###;\n//                                         ^^^ this is not the end of the raw string\n```\n\n\nMulti-Line Literal Strings\n--------------------------\n\nA string wrapped by a pair of back-tick (`` ` ``) characters is interpreted _literally_,\nmeaning that every single character that lies between the two back-ticks is taken verbatim.\nThis include new-lines, whitespaces, escape characters etc.\n\n```js\nlet x = `hello, world! \"\\t\\x42\"\n  hello world again! 'x'\n     this is the last time!!! `;\n\n// The above is the same as:\nlet x = \"hello, world! \\\"\\\\t\\\\x42\\\"\\n  hello world again! 'x'\\n     this is the last time!!! \";\n```\n\nIf a back-tick (`` ` ``) appears at the _end_ of a line, then it is understood that the entire text\nblock starts from the _next_ line; the starting new-line character is stripped.\n\n```js\nlet x = `\n        hello, world! \"\\t\\x42\"\n  hello world again! 'x'\n     this is the last time!!!\n`;\n\n// The above is the same as:\nlet x = \"        hello, world! \\\"\\\\t\\\\x42\\\"\\n  hello world again! 'x'\\n     this is the last time!!!\\n\";\n```\n\nTo actually put a back-tick (`` ` ``) character inside a multi-line literal string, use two\nback-ticks together (i.e. ` `` `).\n\n```js\nlet x = `I have a quote \" as well as a back-tick `` here.`;\n\n// The above is the same as:\nlet x = \"I have a quote \\\" as well as a back-tick ` here.\";\n```\n\n\nString Interpolation\n--------------------\n\n~~~admonish question.side.wide \"What if I want `${` inside?\"\n\n\ud83e\udd26 Well, you just _have_ to ask for the impossible, don't you?\n\nCurrently there is no way to escape `${`.  Build the string in three pieces:\n\n```js\n`Interpolations start with \"`\n    + \"${\"\n    + `\" and end with }.`\n```\n</code></pre></p> <p>Multi-line literal strings support string interpolation wrapped in <code>${</code> ... <code>}</code>.</p> <p>Interpolation is not supported for normal string or character literals.</p> <p><code>${</code> ... <code>}</code> acts as a statements block and can contain anything that is allowed within a statements block, including another interpolated string! The last result of the block is taken as the value for interpolation.</p> <p>AviScript uses <code>to_string</code> to convert any value into a string, then physically joins all the sub-strings together.</p> <p>For convenience, if any interpolated value is a BLOB, however, it is automatically treated as a UTF-8 encoded string.  That is because it is rarely useful to interpolate a BLOB into a string, but extremely useful to be able to directly manipulate UTF-8 encoded text.</p> <pre><code>let x = 42;\nlet y = 123;\n\nlet s = `x = ${x} and y = ${y}.`;                   // &lt;- interpolated string\n\nlet s = (\"x = \" + {x} + \" and y = \" + {y} + \".\");   // &lt;- de-sugars to this\n\ns == \"x = 42 and y = 123.\";\n\nlet s = `\nUndeniable logic:\n1) Hello, ${let w = `${x} world`; if x &gt; 1 { w += \"s\" } w}!\n2) If ${y} &gt; ${x} then it is ${y &gt; x}!\n`;\n\ns == \"Undeniable logic:\\n1) Hello, 42 worlds!\\n2) If 123 &gt; 42 then it is true!\\n\";\n\nlet blob = blob(3, 0x21);\n\nprint(blob);                            // prints [212121]\n\nprint(`Data: ${blob}`);                 // prints \"Data: !!!\"\n                                        // BLOB is treated as UTF-8 encoded string\n\nprint(`Data: ${blob.to_string()}`);     // prints \"Data: [212121]\"\n</code></pre>"},{"location":"types/strings-chars/#indexing","title":"Indexing","text":"<p>Strings can be indexed into to get access to any individual character. This is similar to many modern languages but different from Rust.</p>"},{"location":"types/strings-chars/#from-beginning","title":"From beginning","text":"<p>Individual characters within a string can be accessed with zero-based, non-negative integer indices:</p> <p>string <code>[</code> index from 0 to (total number of characters \u2212 1) <code>]</code></p>"},{"location":"types/strings-chars/#from-end","title":"From end","text":"<p>A negative index accesses a character in the string counting from the end, with \u22121 being the last character.</p> <p>string <code>[</code> index from \u22121 to \u2212(total number of characters) <code>]</code></p> <p>```admonish warning.small \"Character indexing can be SLOOOOOOOOW\"</p> <p>Internally, a AviScript string is still stored compactly as a Rust UTF-8 string in order to save memory.</p> <p>Therefore, getting the character at a particular index involves walking through the entire UTF-8 encoded bytes stream to extract individual Unicode characters, counting them on the way.</p> <p>Because of this, indexing can be a slow procedure, especially for long strings. Along the same lines, getting the length of a string (which returns the number of characters, not bytes) can also be slow. <pre><code>Sub-Strings\n-----------\n\nSub-strings, or _slices_ in some programming languages, are parts of strings.\n\nIn AviScript, a sub-string can be specified by indexing with a [range](variables/ranges.md) of characters:\n\n&gt; _string_ `[` _first character (starting from zero)_ `..` _last character (exclusive)_ `]`\n&gt;\n&gt; _string_ `[` _first character (starting from zero)_ `..=` _last character (inclusive)_ `]`\n\nSub-string [ranges](variables/ranges.md) always start from zero counting towards the end of the string.\nNegative [ranges](variables/ranges.md) are not supported.\n\n\nExamples\n--------\n\n```js\nlet name = \"Bob\";\nlet middle_initial = 'C';\nlet last = \"Davis\";\n\nlet full_name = `${name} ${middle_initial}. ${last}`;\nfull_name == \"Bob C. Davis\";\n\n// String building with different types\nlet age = 42;\nlet record = `${full_name}: age ${age}`;\nrecord == \"Bob C. Davis: age 42\";\n\n// Unlike Rust, AviScript strings can be indexed to get a character\n// (disabled with 'no_index')\nlet c = record[4];\nc == 'C';                               // single character\n\nlet slice = record[4..8];               // sub-string slice\nslice == \" C. D\";\n\nts.s = record;                          // custom type properties can take strings\n\nlet c = ts.s[4];\nc == 'C';\n\nlet c = ts.s[-4];                       // negative index counts from the end\nc == 'e';\n\nlet c = \"foo\"[0];                       // indexing also works on string literals...\nc == 'f';\n\nlet c = (\"foo\" + \"bar\")[5];             // ... and expressions returning strings\nc == 'r';\n\nlet text = \"hello, world!\";\ntext[0] = 'H';                          // modify a single character\ntext == \"Hello, world!\";\n\ntext[7..=11] = \"Earth\";                 // modify a sub-string slice\ntext == \"Hello, Earth!\";\n\n// Escape sequences in strings\nrecord += \" \\u2764\\n\";                  // escape sequence of '\u2764' in Unicode\nrecord == \"Bob C. Davis: age 42 \u2764\\n\";  // '\\n' = new-line\n\n// Unlike Rust, AviScript strings can be directly modified character-by-character\n// (disabled with 'no_index')\nrecord[4] = '\\x58'; // 0x58 = 'X'\nrecord == \"Bob X. Davis: age 42 \u2764\\n\";\n\n// Use 'in' to test if a substring (or character) exists in a string\n\"Davis\" in record == true;\n'X' in record == true;\n'C' in record == false;\n\n// Strings can be iterated with a 'for' statement, yielding characters\nfor ch in record {\n    print(ch);\n}\n</code></pre></p>"},{"location":"types/timestamps/","title":"Timestamps","text":"<p>Timestamps are provided by the via the <code>timestamp</code> function.</p> <p><code>type_of()</code> a timestamp returns <code>\"timestamp\"</code>.</p>"},{"location":"types/timestamps/#built-in-functions","title":"Built-in Functions","text":"<p>The following methods operate on timestamps.</p> Function Parameter(s) Description <code>elapsed</code> method and property none returns the number of seconds since the timestamp <code>+</code> operator number of seconds to add returns a new timestamp with a specified number of seconds added <code>+=</code> operator number of seconds to add adds a specified number of seconds to the timestamp <code>-</code> operator number of seconds to subtract returns a new timestamp with a specified number of seconds subtracted <code>-=</code> operator number of seconds to subtract subtracts a specified number of seconds from the timestamp <code>-</code> operator <ol><li>later timestamp</li><li>earlier timestamp</li></ol> returns the number of seconds between the two timestamps <p>The following time-related functions are also available.</p> Function Parameter(s) Description <code>sleep</code> number of seconds to sleep blocks the current thread for a specified number of seconds"},{"location":"types/timestamps/#examples","title":"Examples","text":"<pre><code>let now = timestamp();\n\n// Do some lengthy operation...\n\nif now.elapsed &gt; 30.0 {\n    print(\"takes too long (over 30 seconds)!\")\n}\n</code></pre>"},{"location":"types/values-and-types/","title":"Value Types","text":"<p>The following primitive value types are supported natively.</p> Category <code>type_of()</code> <code>to_string()</code> System integer <code>\"i32\"</code> or <code>\"i64\"</code> <code>\"42\"</code>, <code>\"123\"</code> etc. Other integer number <code>\"i32\"</code>, <code>\"u64\"</code> etc. <code>\"42\"</code>, <code>\"123\"</code> etc. Integer numeric range <code>\"range\"</code>, <code>\"range=\"</code> <code>\"2..7\"</code>, <code>\"0..=15\"</code> etc. Floating-point number <code>\"f32\"</code> or <code>\"f64\"</code> <code>\"123.4567\"</code> etc. Fixed precision decimal number <code>\"decimal\"</code> <code>\"42\"</code>, <code>\"123.4567\"</code> etc. Boolean value <code>\"bool\"</code> <code>\"true\"</code> or <code>\"false\"</code> Unicode character <code>\"char\"</code> <code>\"A\"</code>, <code>\"x\"</code> etc. Immutable Unicode string <code>\"string\"</code> <code>\"hello\"</code> etc. Array <code>\"array\"</code> <code>\"[ 1, 2, 3 ]\"</code> etc. Byte array \u2013 <code>BLOB</code> <code>\"blob\"</code> <code>\"[01020304abcd]\"</code> etc. Object map <code>\"map\"</code> <code>\"#{ \"a\": 1, \"b\": true }\"</code> etc. Timestamp <code>\"timestamp\"</code> <code>\"&lt;timestamp&gt;\"</code> Function pointer <code>\"Fn\"</code> <code>\"Fn(foo)\"</code> etc. Dynamic value (i.e. can be anything) the actual type actual value Shared value (a reference-counted, shared dynamic value, created via closures the actual type actual value Nothing/void/nil/null/Unit (or whatever it is called) <code>\"()\"</code> <code>\"\"</code> (empty string) <p>```admonish warning.small \"All types are distinct\"</p> <p>All types are treated strictly distinct by AviScript, meaning that <code>i32</code> and <code>i64</code> and <code>u32</code> are completely different. They cannot even be added together.</p> <p>This is very similar to Rust. <pre><code>```admonish info.small \"Strings\"\n\n[strings](types/strings-chars.md) in AviScript are _immutable_, meaning that they can be shared but not modified.\n\nAny modification done to a AviScript string causes the [string](types/strings-chars.md) to be cloned and\nthe modifications made to the copy.\n</code></pre></p> <p>```admonish tip.small \"Tip: Convert to string\"</p> <p>The <code>to_string</code> function converts a standard type into a string for display purposes.</p> <p>The <code>to_debug</code> function converts a standard type into a string in debug format. ```</p>"},{"location":"types/dynamic/","title":"Dynamic Type","text":"<p>Add description here\u2026</p>"},{"location":"types/dynamic/#contents","title":"Contents","text":"<p>Dynamic Dynamic Tag</p>"},{"location":"types/dynamic/dynamic-tag/","title":"Dynamic Value Tag","text":"<p>Each dynamic value can contain a tag that is <code>i32</code> and can contain any arbitrary 32-bit signed data.</p> <p>On 32-bit targets, however, the tag is only <code>i16</code> (16-bit signed).</p> <p>The tag defaults to zero.</p> <p>```admonish bug.small \"Value out of bounds\"</p> <p>It is an error to set a tag to a value beyond the bounds of <code>i32</code> (<code>i16</code> on 32-bit targets). <pre><code>Examples\n--------\n\n```rust\nlet x = 42;\n\nx.tag == 0;             // tag defaults to zero\n\nx.tag = 123;            // set tag value\n\nset_tag(x, 123);        // 'set_tag' function also works\n\nx.tag == 123;           // get updated tag value\n\nx.tag() == 123;         // method also works\n\ntag(x) == 123;          // function call style also works\n\nx.tag[3..5] = 2;        // tag can be used as a bit-field\n\nx.tag[3..5] == 2;\n\nlet y = x;\n\ny.tag == 123;           // the tag is copied across assignment\n\ny.tag = 3000000000;     // runtime error: 3000000000 is too large for 'i32'\n</code></pre></p>"},{"location":"types/dynamic/dynamic-tag/#practical-applications","title":"Practical Applications","text":"<p>Attaching arbitrary information together with a value has a lot of practical uses.</p>"},{"location":"types/dynamic/dynamic-tag/#identify-code-path","title":"Identify code path","text":"<p>For example, it is easy to attach an ID number to a value to indicate how or why that value is originally set.</p> <p>This is tremendously convenient for debugging purposes where it is necessary to figure out which code path a particular value went through.</p> <p>After the script is verified, all tag assignment statements can simply be removed.</p> <pre><code>const ROUTE1 = 1;\nconst ROUTE2 = 2;\nconst ROUTE3 = 3;\nconst ERROR_ROUTE = 9;\n\nfn some_complex_calculation(x) {\n    let result;\n\n    if some_complex_condition(x) {\n        result = 42;\n        result.tag = ROUTE1;        // record route #1\n    } else if some_other_very_complex_condition(x) == 1 {\n        result = 123;\n        result.tag = ROUTE2;        // record route #2\n    } else if some_non_understandable_calculation(x) &gt; 0 {\n        result = 0;\n        result.tag = ROUTE3;        // record route #3\n    } else {\n        result = -1;\n        result.tag = ERROR_ROUTE;   // record error\n    }\n\n    result  // this value now contains the tag\n}\n\nlet my_result = some_complex_calculation(key);\n\n// The code path that 'my_result' went through is now in its tag.\n\n// It is now easy to trace how 'my_result' gets its final value.\n\nprint(`Result = ${my_result} and reason = ${my_result.tag}`);\n</code></pre>"},{"location":"types/dynamic/dynamic-tag/#identify-data-source","title":"Identify data source","text":"<p>It is convenient to use the tag value to record the source of a piece of data.</p> <pre><code>let x = [0, 1, 2, 3, 42, 99, 123];\n\n// Store the index number of each value into its tag before\n// filtering out all even numbers, leaving only odd numbers\nlet filtered = x.map(|v, i| { v.tag = i; v }).filter(|v| v.is_odd());\n\n// The tag now contains the original index position\n\nfor (data, i) in filtered {\n    print(`${i + 1}: Value ${data} from position #${data.tag + 1}`);\n}\n</code></pre>"},{"location":"types/dynamic/dynamic-tag/#identify-code-conditions","title":"Identify code conditions","text":"<p>The tag value may also contain a bit-field of up to 32 (16 under 32-bit targets) individual bits, recording up to 32 (or 16 under 32-bit targets) logic conditions that contributed to the value.</p> <p>Again, after the script is verified, all tag assignment statements can simply be removed.</p> <pre><code>fn some_complex_calculation(x) {\n    let result = x;\n\n    // Check first condition\n    if some_complex_condition() {\n        result += 1;\n        result.tag[0] = true;   // Set first bit in bit-field\n    }\n\n    // Check second condition\n    if some_other_very_complex_condition(x) == 1 {\n        result *= 10;\n        result.tag[1] = true;   // Set second bit in bit-field\n    }\n\n    // Check third condition\n    if some_non_understandable_calculation(x) &gt; 0 {\n        result -= 42;\n        result.tag[2] = true;   // Set third bit in bit-field\n    }\n\n    // Check result\n    if result &gt; 100 {\n        result = 0;\n        result.tag[3] = true;   // Set forth bit in bit-field\n    }\n\n    result\n}\n\nlet my_result = some_complex_calculation(42);\n\n// The tag of 'my_result' now contains a bit-field indicating\n// the result of each condition.\n\n// It is now easy to trace how 'my_result' gets its final value.\n// Use indexing on the tag to get at individual bits.\n\nprint(`Result = ${my_result}`);\nprint(`First condition = ${my_result.tag[0]}`);\nprint(`Second condition = ${my_result.tag[1]}`);\nprint(`Third condition = ${my_result.tag[2]}`);\nprint(`Result check = ${my_result.tag[3]}`);\n</code></pre>"},{"location":"types/dynamic/dynamic-tag/#return-auxillary-info","title":"Return auxillary info","text":"<p>Sometimes it is useful to return auxillary info from a function.</p> <pre><code>// Verify Bell's Inequality by calculating a norm\n// and comparing it with a hypotenuse.\n// https://en.wikipedia.org/wiki/Bell%27s_theorem\n//\n// Returns the smaller of the norm or hypotenuse.\n// Tag is 1 if norm &lt;= hypo, 0 if otherwise.\nfn bells_inequality(x, y, z) {\n    let norm = sqrt(x ** 2 + y ** 2);\n    let result;\n\n    if norm &lt;= z {\n        result = norm;\n        result.tag = 1;\n    } else {\n        result = z;\n        result.tag = 0;\n    }\n\n    result\n}\n\nlet dist = bells_inequality(x, y, z);\n\nprint(`Value = ${dist}`);\n\nif dist.tag == 1 {\n    print(\"Local realism maintained! Einstein rules!\");\n} else {\n    print(\"Spooky action at a distance detected! Einstein will hate this...\");\n}\n</code></pre>"},{"location":"types/dynamic/dynamic-tag/#poor-mans-tuples","title":"Poor-man's tuples","text":"<p>AviScript does not have tuples (nor does JavaScript in this sense).</p> <p>Similar to the JavaScript situation, practical alternatives using AviScript include returning an object map or an array.</p> <p>Both of these alternatives, however, incur overhead that may be wasteful when the amount of additional information is small \u2013 e.g. in many cases, a single <code>bool</code>, or a small number.</p> <p>To return a number of small values from functions, the tag value as a bit-field is an ideal container without resorting to a full-blown object map or array.</p> <pre><code>// This function essentially returns a tuple of four numbers:\n// (result, a, b, c)\nfn complex_calc(x, y, z) {\n    let a = x + y;\n    let b = x - y + z;\n    let c = (a + b) * z / y;\n    let r = do_complex_calculation(a, b, c);\n\n    // Store 'a', 'b' and 'c' into tag if they are small\n    r.tag[0..8] = a;\n    r.tag[8..16] = b;\n    r.tag[16..32] = c;\n\n    r\n}\n\n// Deconstruct the tuple\nlet result = complex_calc(x, y, z);\nlet a = r.tag[0..8];\nlet b = r.tag[8..16];\nlet c = r.tag[16..32];\n</code></pre>"},{"location":"types/dynamic/dynamic/","title":"Dynamic Values","text":"<p>A dynamic value can be any type.</p> <pre><code>let x = 42;         // value is an integer\n\nx = 123.456;        // value is now a floating-point number\n\nx = \"hello\";        // value is now a string\n\nx = x.len &gt; 0;      // value is now a boolean\n\nx = [x];            // value is now an array\n\nx = #{x: x};        // value is now an object map\n</code></pre>"},{"location":"types/dynamic/dynamic/#use-type_of-to-get-value-type","title":"Use <code>type_of()</code> to Get Value Type","text":"<p>Because <code>type_of()</code> a dynamic value returns the type of the actual value, it is usually used to perform type-specific actions based on the actual value's type.</p> <pre><code>let mystery = get_some_dynamic_value();\n\nswitch type_of(mystery) {\n    \"()\" =&gt; print(\"Hey, I got the unit () here!\"),\n    \"i64\" =&gt; print(\"Hey, I got an integer here!\"),\n    \"f64\" =&gt; print(\"Hey, I got a float here!\"),\n    \"decimal\" =&gt; print(\"Hey, I got a decimal here!\"),\n    \"range\" =&gt; print(\"Hey, I got an exclusive range here!\"),\n    \"range=\" =&gt; print(\"Hey, I got an inclusive range here!\"),\n    \"string\" =&gt; print(\"Hey, I got a string here!\"),\n    \"bool\" =&gt; print(\"Hey, I got a boolean here!\"),\n    \"array\" =&gt; print(\"Hey, I got an array here!\"),\n    \"blob\" =&gt; print(\"Hey, I got a BLOB here!\"),\n    \"map\" =&gt; print(\"Hey, I got an object map here!\"),\n    \"Fn\" =&gt; print(\"Hey, I got a function pointer here!\"),\n    \"timestamp\" =&gt; print(\"Hey, I got a time-stamp here!\"),\n    \"TestStruct\" =&gt; print(\"Hey, I got the TestStruct custom type here!\"),\n    _ =&gt; print(`I don't know what this is: ${type_of(mystery)}`)\n}\n</code></pre>"},{"location":"types/oop/","title":"Oriented Object Programming (OOP)","text":"<p>Add description here\u2026</p>"},{"location":"types/oop/#contents","title":"Contents","text":"<p>Getters Setters Methods</p>"},{"location":"types/oop/getters-setters/","title":"Properties","text":"<p>Data types typically expose properties, which can be accessed in a Rust-like syntax:</p> <p>object <code>.</code> property</p> <p>object <code>.</code> property <code>=</code> value <code>;</code></p> <p>A runtime error is raised if the property does not exist for the object's data type.</p>"},{"location":"types/oop/getters-setters/#elvis-operator","title":"Elvis Operator","text":"<p>The Elvis operator can be used to short-circuit processing if the object itself is <code>()</code>.</p> <p><code>// returns () if object is ()</code> object <code>?.</code> property</p> <p><code>// no action if object is ()</code> object <code>?.</code> property <code>=</code> value <code>;</code></p>"},{"location":"types/oop/methods/","title":"Methods","text":"<p>Data types may have methods that can be called:</p> <p>object <code>.</code> method <code>(</code> parameters ... <code>)</code></p> <p>A runtime error is raised if the appropriate method does not exist for the object's data type.</p>"},{"location":"types/oop/methods/#elvis-operator","title":"Elvis Operator","text":"<p>The Elvis operator can be used to short-circuit the method call when the object itself is <code>()</code>.</p> <p><code>// method is not called if object is ()</code> object <code>?.</code> method <code>(</code> parameters ... <code>)</code></p>"},{"location":"variables/","title":"Variables","text":"<p>Declaring and manipulating variables, indexing, and ranges.</p>"},{"location":"variables/#contents","title":"Contents","text":"<p>Assignment Constants Indexing Ranges Variables</p>"},{"location":"variables/assignment/","title":"Assignments","text":"<p>Value assignments to variables use the <code>=</code> symbol.</p> <pre><code>let foo = 42;\n\nbar = 123 * 456 - 789;\n\nx[1][2].prop = do_calculation();\n</code></pre>"},{"location":"variables/assignment/#valid-assignment-targets","title":"Valid Assignment Targets","text":"<p>The left-hand-side (LHS) of an assignment statement must be a valid l-value, which must be rooted in a variable, potentially extended via indexing or properties.</p> <p>~~~admonish bug \"Assigning to invalid l-value\"</p> <p>Expressions that are not valid l-values cannot be assigned to.</p> <p><pre><code>x = 42;                 // variable is an l-value\n\nx[1][2][3] = 42         // variable indexing is an l-value\n\nx.prop1.prop2 = 42;     // variable property is an l-value\n\nfoo(x) = 42;            // syntax error: function call is not an l-value\n\nx.foo() = 42;           // syntax error: method call is not an l-value\n\n(x + y) = 42;           // syntax error: binary op is not an l-value\n</code></pre> ~~~</p>"},{"location":"variables/assignment/#values-are-cloned","title":"Values are Cloned","text":"<p>Values assigned are always cloned. So care must be taken when assigning large data types (such as arrays).</p> <p>```rust x = y;                  // value of 'y' is cloned</p> <p>x == y;                 // both 'x' and 'y' hold different copies                         // of the same value ```</p>"},{"location":"variables/assignment/#moving-data","title":"Moving Data","text":"<p>When assigning large data types, sometimes it is desirable to move the data instead of cloning it.</p> <p>Use the <code>take</code> function to move data.</p>"},{"location":"variables/assignment/#the-original-variable-is-left-with","title":"The original variable is left with <code>()</code>","text":"<p>```rust x = take(y);            // value of 'y' is moved to 'x'</p> <p>y == ();                // 'y' now holds '()'</p> <p>x != y;                 // 'x' holds the original value of 'y' ```</p>"},{"location":"variables/assignment/#return-large-data-types-from-functions","title":"Return large data types from functions","text":"<p><code>take</code> is convenient when returning large data types from a function.</p> <p>```rust fn get_large_value_naive() {     let large_result = do_complex_calculation();</p> <pre><code>large_result.done = true;\n\n// Return a cloned copy of the result, then the\n// local variable 'large_result' is thrown away!\nlarge_result\n</code></pre> <p>}</p> <p>fn get_large_value_smart() {     let large_result = do_complex_calculation();</p> <pre><code>large_result.done = true;\n\n// Return the result without cloning!\n// Method style call is also OK.\nlarge_result.take()\n</code></pre> <p>} ```</p>"},{"location":"variables/assignment/#assigning-large-data-types-to-object-map-properties","title":"Assigning large data types to object map properties","text":"<p><code>take</code> is useful when assigning large data types to object map properties.</p> <p>```rust let x = [];</p> <p>// Build a large array for n in 0..1000000 { x += n; }</p> <p>// The following clones the large array from 'x'. // Both 'my_object.my_property' and 'x' now hold exact copies // of the same large array! my_object.my_property = x;</p> <p>// Move it to object map property via 'take' without cloning. // 'x' now holds '()'. my_object.my_property = x.take();</p> <p>// Without 'take', the following must be done to avoid cloning: my_object.my_property = [];</p> <p>for n in 0..1000000 { my_object.my_property += n; } ```</p>"},{"location":"variables/constants/","title":"Constants","text":"<p>Constants can be defined using the <code>const</code> keyword and are immutable.</p> <pre><code>const X;            // 'X' is a constant '()'\n\nconst X = 40 + 2;   // 'X' is a constant 42\n\nprint(X * 2);       // prints 84\n\nX = 123;            // &lt;- syntax error: constant modified\n</code></pre> <p>```admonish tip.small \"Tip: Naming\"</p> <p>Constants follow the same naming rules as variables, but as a convention are often named with all-capital letters. <pre><code>Automatic Global Module\n-----------------------\n\nWhen a [constant](variables/constants.md) is declared at global scope, it is added to a special\n[module](modules/index.md) called `global`.\n\n[Functions](functions/functions.md) can access those [constants](variables/constants.md) via the special `global`\n[module](modules/index.md).\n\n```rust\nconst CONSTANT = 42;        // this constant is automatically added to 'global'\n\n{\n    const INNER = 0;        // this constant is not at global level\n}                           // &lt;- it goes away here\n\nfn foo(x) {\n    x *= global::CONSTANT;  // ok! 'CONSTANT' exists in 'global'\n\n    x * global::INNER       // &lt;- error: constant 'INNER' not found in 'global'\n}\n</code></pre></p>"},{"location":"variables/indexing/","title":"Indexing","text":"<p>```admonish tip.side \"Tip: Non-integer index\"</p> <p>Some data types take an index that is not an integer. For example, object map indices are strings. ```</p> <p>Some data types, such as arrays, can be indexed via a Rust-like syntax:</p> <p>object <code>[</code> index <code>]</code></p> <p>object <code>[</code> index <code>]</code> <code>=</code> value <code>;</code></p> <p>Usually, a runtime error is raised if the index value is out of bounds or does not exist for the object's data type.</p>"},{"location":"variables/indexing/#elvis-notation","title":"Elvis Notation","text":"<p>The Elvis notation is similar except that it returns <code>()</code> if the object itself is <code>()</code>.</p> <p><code>// returns () if object is ()</code> object <code>?[</code> index <code>]</code></p> <p><code>// no action if object is ()</code> object <code>?[</code> index <code>]</code> <code>=</code> value <code>;</code></p>"},{"location":"variables/ranges/","title":"Ranges","text":""},{"location":"variables/ranges/#syntax","title":"Syntax","text":"<p>Numeric ranges can be constructed by the <code>..</code> (exclusive) or <code>..=</code> (inclusive) operators.</p>"},{"location":"variables/ranges/#exclusive-range","title":"Exclusive range","text":"<p>start <code>..</code> end</p> <p>An exclusive range does not include the last (i.e. \"end\") value.</p> <p><code>type_of()</code> an exclusive range returns <code>\"range\"</code>.</p>"},{"location":"variables/ranges/#inclusive-range","title":"Inclusive range","text":"<p>start <code>..=</code> end</p> <p>An inclusive range includes the last (i.e. \"end\") value.</p> <p><code>type_of()</code> an inclusive range returns <code>\"range=\"</code>.</p>"},{"location":"variables/ranges/#usage-scenarios","title":"Usage Scenarios","text":"<p>Ranges are commonly used in the following scenarios.</p> Scenario Example <code>for</code> statements <code>for n in 0..100 { ... }</code> <code>in</code> expressions <code>if n in 0..100 { ... }</code> <code>switch</code>expressions <code>switch n { 0..100 =&gt; ... }</code> Bit-fields access <code>let x = n[2..6];</code> Bits iteration <code>for bit in n.bits(2..=9) { ... }</code> Array range-based APIs <code>array.extract(2..8)</code> BLOB range-based APIs <code>blob.parse_le_int(4..8)</code> string range-based APIs <code>string.sub_string(4..=12)</code> Characters iteration <code>for ch in string.bits(4..=12) { ... }</code>"},{"location":"variables/ranges/#built-in-functions","title":"Built-in Functions","text":"<p>The following methods operate on ranges.</p> Function Parameter(s) Description <code>start</code> method and property beginning of the range <code>end</code> method and property end of the range <code>contains</code>, <code>in</code> operator number to check does this range contain the specified number? <code>is_empty</code> method and property returns <code>true</code> if the range contains no items <code>is_inclusive</code> method and property is the range inclusive? <code>is_exclusive</code> method and property is the range exclusive?"},{"location":"variables/ranges/#tldr","title":"TL;DR","text":"<p>```admonish question \"What happened to the open-ended ranges?\"</p> <p>Rust has open-ended ranges, such as <code>start..</code>, <code>..end</code> and <code>..=end</code>.  They are not available in AviScript.</p> <p>They are not needed because AviScript can overload functions.</p> <p>Typically, an API accepting ranges as parameters would have equivalent versions that accept a starting position and a length (the standard <code>start + len</code> pair), as well as a versions that accept only the starting position (the length assuming to the end).</p> <p>In fact, usually all versions redirect to a call to one single version.</p> <p>Therefore, there should always be a function that can do what open-ended ranges are intended for.</p> <p>The left-open form (i.e. <code>..end</code> and <code>..=end</code>) is trivially replaced by using zero as the starting position with a length that corresponds to the end position (for <code>..end</code>).</p> <p>The right-open form (i.e. <code>start..</code>) is trivially replaced by the version taking a single starting position.</p> <p><pre><code>let x = [1, 2, 3, 4, 5];\n\nx.extract(0..3);    // normal range argument\n                    // copies 'x' from positions 0-2\n\nx.extract(2);       // copies 'x' from position 2 onwards\n                    // equivalent to '2..'\n\nx.extract(0, 2);    // copies 'x' from beginning for 2 items\n                    // equivalent to '..2'\n</code></pre> ```</p>"},{"location":"variables/variables/","title":"Variables","text":""},{"location":"variables/variables/#valid-names","title":"Valid Names","text":"<p>Variables in AviScript follow normal C naming rules \u2013 must contain only ASCII letters, digits and underscores <code>_</code>.</p> Character set Description <code>A</code> ... <code>Z</code> Upper-case ASCII letters <code>a</code> ... <code>z</code> Lower-case ASCII letters <code>0</code> ... <code>9</code> Digit characters <code>_</code> Underscore character <p>However, a variable name must also contain at least one ASCII letter, and an ASCII letter must come before any digits. In other words, the first character that is not an underscore <code>_</code> must be an ASCII letter and not a digit.</p> <p>```admonish question.side.wide \"Why this restriction?\"</p> <p>To reduce confusion (and subtle bugs) because, for instance, <code>_1</code> can easily be misread (or mistyped) as <code>-1</code>.</p> <p>AviScript is dynamic without type checking, so there is no compiler to catch these typos. <pre><code>Therefore, some names, e.g. `_`, `_42foo`, `_1` etc., are not valid in AviScript.\n\nFor example: `c3po` and `_r2d2_` are valid variable names, but `3abc` and `____49steps` are not.\n\nVariable names are case _sensitive_.\n\nVariable names also cannot be the same as a [keyword](meta/keywords.md) (active or reserved).\n\n```admonish warning \"Avoid names longer than 11 letters on 32-Bit\"\n\nAviScript _inlines_ a string, which avoids allocations unless it is over its internal limit\n(23 ASCII characters on 64-bit, but only 11 ASCII characters on 32-bit).\n\nOn 64-bit systems, _most_ variable names are shorter than 23 letters, so this is unlikely to become\nan issue.\n\nHowever, on 32-bit systems, take care to limit, where possible, variable names to within 11 letters.\nThis is particularly true for local variables inside a hot loop, where they are created and\ndestroyed in rapid succession.\n\n~~~js\n// The following is SLOW on 32-bit\nfor my_super_loop_variable in array {\n    print(`Super! ${my_super_loop_variable}`);\n}\n\n// Suggested revision:\nfor loop_var in array {\n    print(`Super! ${loop_var}`);\n}\n~~~\n</code></pre></p>"},{"location":"variables/variables/#declare-a-variable","title":"Declare a Variable","text":"<p>Variables are declared using the <code>let</code> keyword.</p> <p>```admonish tip.small \"Tip: No initial value\"</p> <p>Variables do not have to be given an initial value. If none is provided, it defaults to <code>()</code>. <pre><code>```admonish warning.small \"Variables are local\"\n\nA variable defined within a [statements block](statements/statements.md) is _local_ to that block.\n</code></pre></p> <p>~~~admonish tip.small \"Tip: <code>is_def_var</code>\"</p> <p>Use <code>is_def_var</code> to detect if a variable is defined. ~~~</p> <p>```rust let x;              // ok - value is '()' let x = 3;          // ok let x = 42;        // ok let x = 42;        // also ok let x = 42;       // still ok</p> <p>let _ = 123;        // &lt;- syntax error: illegal variable name let _9 = 9;         // &lt;- syntax error: illegal variable name</p> <p>let x = 42;         // variable is 'x', lower case let X = 123;        // variable is 'X', upper case</p> <p>print(x);           // prints 42 print(X);           // prints 123</p> <p>{     let x = 999;    // local variable 'x' shadows the 'x' in parent block</p> <pre><code>print(x);       // prints 999\n</code></pre> <p>}</p> <p>print(x);           // prints 42 - the parent block's 'x' is not changed</p> <p>let x = 0;          // new variable 'x' shadows the old 'x'</p> <p>print(x);           // prints 0</p> <p>is_def_var(\"x\") == true;</p> <p>is_def_var(\"_x\") == true;</p> <p>is_def_var(\"y\") == false; ```</p>"},{"location":"variables/variables/#shadowing","title":"Shadowing","text":"<p>New variables automatically shadow existing ones of the same name.  There is no error.</p> <p>```rust let x = 42; let y = 123;</p> <p>print(x);           // prints 42</p> <p>let x = 88;         // &lt;- 'x' is shadowed here</p> <p>// At this point, it is no longer possible to access the // original 'x' on the first line...</p> <p>print(x);           // prints 88</p> <p>let x = 0;          // &lt;- 'x' is shadowed again</p> <p>// At this point, it is no longer possible to access both // previously-defined 'x'...</p> <p>print(x);           // prints 0</p> <p>{     let x = 999;    // &lt;- 'x' is shadowed in a block</p> <pre><code>print(x);       // prints 999\n</code></pre> <p>}</p> <p>print(x);           // prints 0 - shadowing within the block goes away</p> <p>print(y);           // prints 123 - 'y' is not shadowed ```</p>"}]}